This document discusses the RDSS Libraries imake system and how to use it.
It is not a complete discussion of the imake system; other sources of
information appear in the Introduction section.  

Users who are installing RDSS Libraries for the first time should consult the
libinstall.doc or libinstall.ps that accompanies the RDSS Libraries
distribution.

Developers who simply want to know what commands to invoke to build a
subdirectory or subdirectories should read the section:  COMMON COMMANDS.

Much of the information contained herein was borrowed from Gary Granger's
excellent document on Zeb's imake system, Zeb-Imake.doc and modified as 
needed to pertain to the RDSS Libraries (thanks Gary!).

 
IMAKE GUIDE FOR RDSS LIBRARIES DEVELOPERS
=========================================
 
 
                        --- Contents ---
 
        Introduction
 
        How Imake Works

        Common Commands
 
        Imakefiles Versus Makefile.cpp Files
 
        Changes Made to the RDSS Libraries with the Installation of Imake
 
        General Imake Features
 
        RDSS Libraries Imakefile Features
 
        Common Pitfalls
 
        Tips and Suggestions
 
        Questions or Comments


Introduction
============
 
This document describes the RDSS Libraries' use of the Imake system to 
handle its distribution hierarchy.  First, to give credit where credit is due:
Imake was originally written by Todd Brunhoff, Tektronix, inc., while a
guest engineer at Project Athena, MIT, and further developed by Jim
Fulton of the X Consortium.  Imake is copyrighted by MIT, but
permission has been granted for any use and distribution (as long as
the Copyright message is distributed as well and all that...).
 
This document describes the general operation of imake and its
implementation in the RDSS directory hierarchy.  It also offers some
guidelines for 'making' the most out of Imakefiles.  For most intents
and purposes, you should notice little difference in the behavior of
Imake-generated Makefiles and the original cpp-generated Makefiles.
The most common targets, such as depend, all, install, clean, and
Makefile (mf), still exist.  New ones, such as includes and Makefiles,
are described below.  If a directory's Makefile is not behaving as it
did prior to Imake, or you just don't like the behavior, or you need to
make some changes, then try adjusting the Imakefile yourself with the
guidelines given here.  But also please feel very welcome to report any
problems to:
    
                        Michele Case
                        case@stout.atd.ucar.edu

^L
Some other places to look for information about imake:
 
  o     The imake(1) man page, imake.man.
  o     The make(1) man page.
  o     The cpp(1) man page.
 
You should be familiar with make and cpp to get the most from
this document.  The imake man page offers some details and
command line options which are not discussed here.  The imake man
page, as well as the imake source and configuration files, can be
found in the RDSS Libraries directory /rdss/imake, or in the X11 distribution
in mit/config.
 
This document refers to several files which Imake uses to generate
Makefiles.  All of these files can be found in the X11 distribution
under mit/config, or in /rdss/imake:

  o     Imake.tmpl
  o     Imake.rules
  o     *.cf
  o     site.def
 
The /rdss/imake directory includes the source files and makefiles
necessary for building the imake program.  This directory is almost an
exact copy of the X11 directory .../mit/config.  For the RDSS Libraries
distribution, the X11 Project.tmpl file has been removed, and the
Imakefile has been slightly modified.  The hope is that as the imake
system evolves and new system configurations are added, the /rdss/imake
directory can be easily updated by directly copying the most recent X11
release of imake.  Therefore it is imperative that NO changes be made
to this directory.  All adjustments and edits should be done to files
in the /rdss/config directory.  This directory contains files which
override some of the files and definitions in the imake directory.  By
including the /rdss/config directory before the /rdss/imake directory on
the imake command line, the files in /rdss/config replace some of the
imake configuration files in /rdss/imake.

How Imake Works
===============
 
Imake takes advantage of the C pre-processor to generate a Makefile
from a file called an Imakefile.  Makefile rules and variables are set
through macros defined in a series of files included by Imake.  Imake
tells cpp to include a master template file, Imake.tmpl, which in turn
uses #include directives to include other files, such as the
machine-specific configuration file (with the .cf extension), the
Imake.rules file, the Project.tmpl file, and the Imakefile. The
Project.tmpl file defines common variables, such as install
directories, needed libraries, and include directories, which are
specific to a particular project.  The Imake.rules file defines macros
for common Makefile targets, such as 'depend', 'includes', and 'clean',
and rules for building and installing programs and libraries.  These
macros expand into Makefile rules when processed by cpp to produce the
Makefile.
 
The imake program is necessary to overcome certain limitations of
C pre-processors.  First of all, cpp macros cannot expand into multiple
lines, whereas Makefile targets must be separated from their shell
commands by newlines.  So Imake rules are defined using two consecutive
'@' characters to indicate where newlines should be placed when the
macro is expanded.  Also, C pre-processors are not consistent in their
behavior among different platforms.  Some pre-processors convert
escaped newlines to spaces, others convert tabs to spaces.  Since tabs
are required before each line of a rule's shell commands, imake
attempts to make sure the tabs are there or insert its own tabs in the
cpp output.
 
A Makefile is built from an Imakefile through the following steps:
 
 1) imake invokes cpp, piping both cpp's stdin and stdout.
    Imake sends cpp an include directive to include the Imake template
    file, Imake.tmpl.  Meanwhile, imake filters cpp's output: "@@" is
    replaced with "\n" and lines following targets (those lines
    containing a ':') are prepended with tabs.
 
 2) Imake.tmpl determines the architecture it is being compiled on
    through pre-defined cpp symbols and includes a machine-specific
    configuration file, *.cf.  Then a site.def file is included,
    allowing a particular site to override any .cf definitions
    or any of the Imake.tmpl default symbol definitions.

 3) Imake.tmpl then gives default definitions to any variables
    that were not set in the previously included files.  Here are some
    examples of these machine- and site-specific symbols:
 
    SystemV                             HasSockets
    HasVFork                            HasVoidSignalReturn
    HasSaberC                           HasFortran
    DefaultCDebugFlags                  ArCmd
    InstallCmd                          RanlibCmd
 
    See Imake.tmpl for the full complement.  This isn't even close.
 
 4) Next, Imake.tmpl outputs text which assigns each cpp
    symbol defined so far to the corresponding conventional Makefile
    variable: AR=ArCmd, INSTALL=InstallCmd, CC=CCompiler,
    RANLIB=RanlibCmd, and INSTPGMFLAGS=InstPgmFlags.  Note the name
    convention: cpp symbols are lowercase with capitalized word
    separations, while Make variables are all uppercase.  Remembering
    this can save some confusion when looking through Imakefiles.
 
 5) Imake.tmpl then includes the Project.tmpl file.  The
    Project.tmpl file assigns default values to project-specific cpp
    symbols and then outputs the text which assigns these symbols to
    the corresponding Makefile variables, just as Imake.tmpl does in
    step (4).  For RDSS's project template, two of these variables are
    UIC=UicCmd and ARADD=ArAdd.
 
 6) For the Libraries implementation, Project.tmpl is in /rdss/config.  It
    includes the site-def.h file which indicates the installer's
    choices on various build options.  The last line of the RDSS Libraries
    template includes the RDSSLib.rules file, which defines some rules to
    override the default definitions given in Imake.rules.  The rules
    in RDSSLib.rules are specially designed for the Libraries development
    environment.
 
 7) Imake.tmpl then includes the Imake.rules file.  All of
    the definitions here first test that the rule macro has not been
    defined already.  In this way rules defined in RDSSLib.rules replace
    any definitions that would have occurred in Imake.rules.  For
    example, RDSSLib.rules defines the NormalProgramTarget() macro to
    include an install target, where the Imake.rules definition does
    not. 
    
 8) Next, the Imake.tmpl file includes the actual Imakefile.  Here
    rule macros are expanded, and imake inserts any necessary newlines
    and tabs into the output.
 
 9) Imake.tmpl outputs some targets necessary for all
    Makefiles, such as the following:
 
    Makefile    -- For re-creating the Makefile from the Imakefile
                   using imake.
    clean       -- The generic clean target which removes all
                   object files, core files, etc.
 
    If the Imakefile defined the 'IHaveSubdirs' cpp symbol, targets are
    included for propagating the 'depend', 'includes', 'clean',
    'install', 'all', and 'Makefiles' targets to the subdirectories.
    More on this option later.
 
10) Imake writes the resulting output to a Makefile.  Though this may
    sound long and complicated, the whole process has been methodically
    laid out, and Makefile generation is actually very quick.


Common Commands
===============

Building a subdirectory should behave in much the way it always has:

1.  To build a subdirectory after changing one or more files:

           % make

2.  To install into /locallib or /localbin after you are satisfied with
    the changes:

           % make install

3.  Other targets can be invoked by typing:

           % make targetname

    Targetname can be any target which is listed in the Makefile.


There are differences that should be noted:

1.  Instead of modifying Makefile.cpp when you wish to change the Makefile,
    edit Imakefile instead and then 'make' the Makefile by typing:

           % make Makefile

    This will do what the old 'make Makefile' command did *except* for
    doing the makedepend.  If you want to build the Makefile *and* do a
    makedepend, issue the following command instead:

           % make mf

2.  Install targets no longer automatically install .h files.  If you have
    modified a header file and wish to install it, then type:

	   % make includes

Imakefiles Versus Makefile.cpp Files
====================================
 
The Imakefile system is similar to the Libraries' original Makefile.cpp system.
Both systems rely on the C pre-processor to handle the configuration
and dissemination of distribution-wide variables to the Makefile
hierarchy.  Imake's template files are simply the Libraries' site-def.h
taken to amore thorough and flexible level to maximize portability.  Symbols 
CCompiler and CCOptions, defined in site-def.h, are assigned to Makefile
variables by lines like the following in each Makefile.cpp:
 
CC=CCompiler
CFLAGS=CCOptions IncludeDirs
 
Imake takes care of this assignment outside of the Imakefile by putting
these lines in the template files, thus prepending the general,
distribution-wide information to the directory-specific information in
the Imakefile.  An Imakefile only describes the directory where it is
located.  It knows nothing about its parent or where it is in the rest
of the distribution.  This makes the whole Imakefile system modular,
flexible, and easy to maintain.  Imake also provides the added bonus of
using cpp macros to generate rules as well as variables; any adjustment
required in a rule is made in one rules file, and the whole hierarchy
is automatically updated by the 'Makefiles' target.


Changes Made to RDSS Libraries with the Installation of Imake
=============================================================

Several changes were made to the RDSS Libraries distribution and build 
behavior with the installation of imake.  Most of these changes were
made to make imake more effective in building and maintaining the
Libraries:

1.  Librdss.a has been split into 3 libraries:  librdssui.a librdssutil.a
    and librdssgraph.a.  Users who do not need RDSS Graphics should not have
    to link with unneeded objects, thus decreasing the possibility for
    conflicts.

2.  Because of the split of librdss.a, the SmeMenu subdirectory has been
    eliminated and the files moved to the ui subdirectory.  Since the 
    SmeMenu code has been extensively revised since the original X11 code,
    there is no need to maintain a separate subdirectory; it makes more
    sense to move the code to the ui directory where it is used.

3)  The functionality of the 'Makefile' target has been separated.  The
    'Makefile' target no longer automatically does a 'make depend'.
    During installation, a 'make Makefiles' must be done to make sure
    all Makefiles in the distribution are up-to-date.  Then a 'make
    includes' is done for the whole distribution to install public
    header files in the build's include directory ($(TOP)/include).
    The 'depend' target cannot be performed until after the 'includes'
    target is complete.   Hence the 'Makefile' and 'depend' targets had
    to be separated.  The shorthand 'mf' target, since it is not
    invoked in a hierarchical build, performs both the 'Makefile' and
    'depend' targets.  So when building a Makefile before the includes
    directory has been built, use 'Makefile' rather than 'mf'.  But in
    normal development, you can use 'mf'.

4)  The distribution hierarchy now includes a new subdirectory,
    /rdss/imake, which contains the imake source and necessary
    configuration and template files which are not replaced by
    files in /rdss/config.


General Imake Features
======================
 
Imakefiles are designed to be as machine independent as possible.
Makefile variables are used wherever possible to name source files,
object files, libraries, and even shell commands such as 'rm' and
'cat'.  The use of Makefile variables allows a great deal of
flexibility.  Usually each variable defaults to some normal value in
the makefile, but this value can be overridden from the command line of
the make(1) command.  For example, a programmer may want to compile a
source file with the cpp symbol DEBUG set, even though this is not the
default in the Makefile.  Using an imake-generated Makefile, the make
command would be
 
% make EXTRA_DEFINES=-DDEBUG
 
The same make variables are generated from each and every Imakefile.  So
even without having written the Imakefile originally, a programmer
can be assured that the EXTRA_DEFINES variable is referenced in the
Makefile and will produce the desired results.
 
Imakefile rules are defined once in a central file rather than
redundantly copied into every Makefile which requires a particular
rule.  Thus rules can be adjusted in a single location for different
development behaviors and for machine portability.  For example, here
is the definition of the BuildIncludes() macro:
 
 
#ifndef BuildIncludes
#define BuildIncludes(srclist,dstsubdir,dstupdir)           @@\
includes::                                                  @@\
        MakeDir($(BUILDINCDIR)/dstsubdir)                   @@\
        @(set -x; cd $(BUILDINCDIR)/dstsubdir; for i in srclist; do \ @@\
                $(RM) $$i; \                                @@\
                $(CP) -p $(BUILDINCTOP)/dstupdir/$(CURRENT_DIR)/$$i .; \ @@\
        done)
#endif /* BuildIncludes */
 
Note the "@@" strings at the end of each line.  When invoked in an
Imakefile as BuildIncludes($(HEADERS),.,.), using the definition
in RDSSLib.rules, this macro expands to:

includes::
        @if [ -d $(BUILDINCDIR)/. ]; then set +x; \
        else (set -x; $(MKDIRHIER) $(BUILDINCDIR)/.); fi
        @(set -x; cd $(BUILDINCDIR)/.; for i in $(HEADERS); do \
        $(RM) $$i; \
        $(CP) -p $(BUILDINCTOP)/./$(CURRENT_DIR)/$$i .; \
        done)
 
 
This is a Makefile rule for installing the files in the
'srclist' parameter into the directory $(BUILDINCDIR)/dstsubdir.
[BUILDINCDIR is a Makefile variable that gives the location of the
include directory in use by an entire distribution.  For RDSS Libraries,
BUILDINCDIR usually equals $(TOP)/include, where $(TOP) is the relative
path to the top of the distribution hierarchy.  TOP is set
automatically when Makefiles are generated for subdirectories.  [For
example, in rdss/ui, TOP=..]
 
The header files are in the Makefile HEADERS variable, and the
subdirectory is '.', hence the path back to the top of the include
directory (dstupdir) is '.'.  The most common macros and their uses
will be described in more detail later.
 
The BuildIncludes() macro is an example of a rule which has been
re-defined for RDP's development environment.  Usually, BuildIncludes()
installs header files by simply creating symbolic links in the include
directory to the header file in the source directory.  The Libraries use a
different behavior; header files are copied directly into the
hierarchy's include directory rather than linked.  [The -p option,
which is hopefully portable, preserves the modification time of the
copied file rather than using the time of the copy.]
 
The Imake system offers a great deal of consistency among the
directories of a distribution.  Rules which every Makefile needs, such
as clean and depend, and rules for generating Makefiles, are
automatically included in the generated Makefile.  Distribution-wide
variables (i.e. project template variables) are automatically included
in every Makefile, so that every directory will know where to install
any binaries it creates and what command to use for RANLIB ('ranlib'
for BSD but 'true' for SYSV).  Likewise, rule macros can be adjusted as
necessary from a central file and the changes will automatically be
distributed throughout the distribution.  This can be especially
important when porting distributions to different platforms.  If a
particular rule must do something special on a certain platform, the
rule macro can be adjusted with #ifdef directives to conform to that
platform's requirements.  The adjustments will be reflected throughout
the distribution hierarchy when the Makefiles are re-made.
 
The Imake system has built-in support for subdirectories.
If a directory has subdirectories that must be built, and to which
rules like clean, depend, and includes must be propagated, rules
for these actions can be automatically included in the Makefile.
All that is necessary is the definition of the IHaveSubdirs cpp symbol
and the make variable SUBDIRS in the Imakefile.  Here is an example from
the Libraries' top-level Imakefile:

#define IHaveSubdirs
#define PassCDebugFlags
 
      WORLDOPTS = -k
     CHECKFNSRC = $(UTILSRC)/checkfn
        CHECKFN = $(CHECKFNSRC)/checkfn
 
 
XCOMM Note that only the SUBDIRS variable is conditional.  All known
XCOMM directories and source files will be distributed whether or
XCOMM not they are configured to be compiled.
 
        SUBDIRS = config util ui graphics

DependSubdirs($(SUBDIRS))

The order of the subdirectories is important, since it is the order in
which the subdirectories are built.  Directories whose objects are
needed by other directories should be listed first in the SUBDIRS variable.
The DependSubdirs() macro is included because 'depend:' targets for
subdirectories are not automatically included in the Imake template,
though targets like clean, all, and install are included.
 
The PassCDebugFlags defines any flags that should be propagated to
subdirectories.  For example, if the ./ingest directory is being
compiled with CDEBUGFLAGS=-g, all of the subdirectories will be
compiled with this flag since the ingest Imakefile defines
 
#define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
 
The definition of PassCDebugFlags is included on the make command line
for each of the subdirectories.  
 
Another important feature of Imake is the CURDIR and TOPDIR cpp
symbols.  These symbols are passed from directory to subdirectory on
the imake command line by the Makefiles target.  The Makefile knows its
current directory and appends the subdirectory name to this value to
define the subdirectory's CURDIR symbol.  The TOPDIR symbol is prefixed
with '..' for every subdirectory.  The CURDIR and TOPDIR symbols are
assigned to the CURRENT_DIR and TOP Makefile variables.  For example,
in the ui Makefile, CURRENT_DIR=./ui and TOP=../.  Hence the include
directory can be specified the same way for every Makefile, without
using an absolute pathname, as $(TOP)/include.  If the current
directory is ./ui, $(TOP)/include will be evaluated as
.././include---the correct directory.  For the TOP and CURRENT_DIR
variables to be correctly initialized, a 'make Makefiles' must be done
from the top-level directory.  Once initialized, though, a Makefile
will remember its values each time it is re-made.  This
hierarchy-independent strategy for defining distribution-wide variables
is a large contributor to Imake's flexibility and modularity.


RDSS Libraries Imakefile Features
=================================

The Libraries use some custom-designed Imakefile rule macros for added
capability and convenience.  Consult the /rdss/config/RDSSLib.rules for
a list of macros and a description of each.  If you have any questions about
how to use a rule, feel free to contact the name listed at the end of this
document.


Common Pitfalls
===============
 
The Makefiles target DOES NOT re-make the Makefile in the current
directory.  Therefore if you change the SUBDIRS variable in the Imakefile,
and then do 'make Makefiles', the wrong subdirectories will be used.  Do a
'make Makefile' first.
 
When a Makefile is re-made, makedepend's dependency targets are lost and a
'make depend' is not automatically re-done (unless the 'mf' target was
used.  If some header files change, it is not a bad idea to do a 'make
depend' at that time.  The dependency lists may be out of date, or someone
else may have re-made the Makefile without re-making the dependency lists.
 
Sometimes a Makefile can be corrupted when an incorrect Imakefile is used
to generate a new Makefile.  Just copy Makefile.bak to Makefile, fix the
Imakefile, and try the 'make mf' or 'make Makefile' again.
 
In trying to understand how Imake works, it is helpful to remember that
Makefile variables are evaluated recursively.  So given the following
assignment from Imake.tmpl,
 
ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
 
if INCLUDES is set to '-Imy_include' in an Imakefile AFTER the ALLINCLUDES
assignment above, ALLINCLUDES will evaluate to '-Imy_include ....' in the
Makefile.  It is because of this recursion that assignments like
TOP=../$(TOP) are illegal.


Tips and Suggestions
====================
 
-------------------------------------------------------------------------
To use a make program other than /bin/make, use the MFLAGS variable.
For example, to use GNU make on stout clients:
 
% gmake MFLAGS='MAKE=gmake'
 
The MFLAGS macro is passed down the entire Makefile hierarchy.  Any
command-line flags you wish to add must be in both the MFLAGS rhs and
on the command-line:
 
% gmake -n MFLAGS='-n MAKE=gmake'
 
A more permanent way to substitute make programs is create a link to the
make program of your choice in your home (or home/bin) directory, like so:
 
% ln -s /usr/local/bin/gmake $HOME/bin/make
% set path=($HOME/bin $path)
% rehash
 
 
-------------------------------------------------------------------------
As the saying in the X distribution goes, the easiest way to make a new
Imakefile is to first copy an existing one that is similar to what you
need and then modify it.
 
-------------------------------------------------------------------------
To find out exactly what targets and variables are generated in the
Makefile, first look in the Makefile.  For VERY detailed info, try GNU
make's -p option for printing the Makefile database:
 
% gmake -p -q | more 
 
The output is quite voluminous, hence the necessity of piping.
To get just one variable's value, pipe to 'egrep <variable name>'.
 
-------------------------------------------------------------------------
Take advantage of setting variables on the command line.  If you just want
to make the graphics and ui modules, use this one command:
 
% make SUBDIRS='graphics ui' install
 
If you want to test-link a program with OpenWindows, use
 
% make XLIBS='-L/usr/openwin/lib -lXaw -lXmu -lXt -lX11' <program>
 
Look in .../config/Project.tmpl or a Makefile to see all of the Make
variables which you can override from the command line.
 
-------------------------------------------------------------------------

Imake's flexibility is seriously hindered by fixed include paths, like
"../include/defs.h".  DO NOT use this in your source files, and correct
any files that you find using this construct.
 
-------------------------------------------------------------------------
At the moment, .lf files are not listed as dependencies of the program
target.  So a 'make <program>' will not automatically make sure the .lf
file is up to date, though the 'all' and 'install' targets will.  If
you want the load file to be a program dependency, add the load file
name to the dependent libraries parameter of the program target
macro.
 
-------------------------------------------------------------------------
As you can see from many of the Imakefiles, it is entirely legal and
sometimes very useful to include normal, hardcoded Makefile targets in
an Imakefile.  

 -------------------------------------------------------------------------
If you feel the need for a new rule macro, or find yourself using the
same rule construct in several places, just add a macro to RDSSLib.rules.
Be sure to document it.
 
-------------------------------------------------------------------------
Do not use tests for machine-specific cpp symbols.  Use a cpp symbol
which indicates exactly whether the condition you are testing is true.
For example, use the HasWriteV symbol instead of the more general and
less accurate symbol SunArchitecture.  To add a new symbol, give it a
default in Project.tmpl and use the machine-specific symbols defined
in Imake.tmpl to determine the correct value for the symbol.
 
-------------------------------------------------------------------------
Be sure to keep the Imakefiles up to date.  If you add a source file,
add the filename to the SRCS variable and its object to the appropriate
OBJS variable.  If a file is to be distributed, add it to the DISTFILES
variable.  If you add a subdirectory somewhere which you wish built with
the rest of the distribution, add the subdirectory to the parent
directory Imakefile's SUBDIRS variable.  If the directory should be
distributed but not built, add it to the DISTSUBDIRS variable in the
parent directory Imakefile.
 
-------------------------------------------------------------------------
One of the nice things about using imake for development is its ability to
build Makefile's for directories outside of the standard source tree.  For
example, in a source directory <cur-abs-path>, use
 
% imake -I/rdss/config -I/rdss/imake -DTOPDIR=/rdss -DCURDIR=<cur-abs-path>
 
This sets up a Makefile to use absolute path names for its TOP and
CURRENT_DIR variables, and since include and library paths are relative
to the TOP variable in the Imakefile, the location of the current
directory does not hinder Imake's ability to specify and find files in
the Makefile.
 
You can also use the 'zmkmf' script which is installed in the bin/
directory of the RDSSLibraries tree. This script takes two arguments, a path to
the top directory and a path from the top to the current directory.
If developing in a directory outside the standard source tree, use
absolute paths, as in the previous example:

% zmkmf /rdss <absolute-path>
 
Otherwise, you can use relative paths to make Makefiles from within
the source tree:
 
% zmkmf ./../.. ./ui
 
-------------------------------------------------------------------------
 
Different Libraries configurations can be tested in isolation from rest of the
development hierarchy, within either a development directory or a shadow
directory.  Put a copy of site-def.h in the directory, and set the INCLUDES  
variable in the Imakefile to '-I.'.  The local copy of site-def.h will be
used by the Imakefile and all of the source files rather than the global
distribution copy in rdss/config.  The local site-def.h can be edited to the
configuration you wish to test regardless of the configuration defined in
the global 'site-def.h'.  The INCLUDES variable could also be set on the
command line, as in
 
% make INCLUDES=-I.
 
so that the Imakefile does not have to be changed.  However, this method is
error-prone since you must remember always to add the INCLUDES argument.
It's best just to make changes to the local Imakefile.

Questions or Comments
=====================

If you have any questions or comments about the RDSS Libraries' use of imake,
please feel free to contact:

                    Michele Case
                    NCAR/ATD/RDP
                    (303) 497-8756
                    case@stout.atd.ucar.edu

 

