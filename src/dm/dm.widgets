!
! Display manager widgets.
!
! $Id: dm.widgets,v 1.26 1995-09-22 19:15:58 burghart Exp $
!

define widget SaveConfig form 'Configuration saver'
	noheader
	label l1 'Save configuration as: '
	blank cname variable dm$config width 150 command 'do_cfg_save'
	button help 'Help' command 'help ec-save'
	button doit 'Do It' command 'do_cfg_save'
	button cancel 'Cancel' command 'popdown #ui$form' color red
	newline
	label l2 'Config directory: '
	blank configdir variable configdir width 350
endform


procedure do_cfg_save
	set configdir getftext(ui$form,'configdir')
	local configname quote(getftext(ui$form,'cname'))
	
	cfgsave #configname
	popdown #ui$form
endprocedure



!
! The new version of the window creation widget
!
define widget cw_wintypes intmenu 'Default version'
       title 'Window types'
       line
       entry 'Constant Altitude Plot' 'cw_type "Constant altitude"'
       entry 'Time-series' 'cw_type "Time series"'
       entry 'Skew-t' 'cw_type "Skew-t"'
       entry 'Wind profile' 'cw_type "Wind profile"'
endmenu

procedure cw_type type string
	local qtype quote(type)
	formtext #ui$form wtype #qtype
endprocedure

define widget NewWindow form 'New window'
	noheader
	label Title 'New window creation'
	newline
	label l1 'Window name:'
	blank name '--' width 100
!	newline
	label l2 'type:'
	pulldown wtype 'Constant altitude' menu cw_wintypes width 140
	newline
	button help 'Help' command 'help ec-add'
	button create 'Create window' command 'DoNewWindow'
	button zap 'Cancel' command 'popdown #ui$form' color red
	label gripe ' ' width 200 color red
endform

procedure DoNewWindow
!
! Make sure they gave us a name.
!
	local name getftext(ui$form, 'name')
	if (name = '--')
		formtext #ui$form gripe 'Please give a window name'
		beep
		return
	endif
!
! See if it's one of the types we know.
!
	local t getftext(ui$form, 'wtype')
	if (t = 'Constant altitude')
		set nw_pd 'cap-template'
		set nw_bmap 'big'
	elseif (t = 'Time series')
		set nw_pd 'tseries-template'
		set nw_bmap 'xyplot'
	elseif (t = 'Wind profile')
		set nw_pd 'wind-template'
		set nw_bmap 'xyplot'
	elseif (t = 'Skew-t')
		set nw_pd 'skewt-template'
		set nw_bmap 'sounding'
	elseif (t = 'Time-height profile')
		set nw_pd 'time-height-template'
		set nw_bmap 'xyplot'
	elseif (t = 'RASS profile')
		set nw_pd 'rass-template'
		set nw_bmap 'xyplot'
	elseif (t = 'Line Plot')
		set nw_pd 'lineplot-template'
		set nw_bmap 'xyplot'
!
! Hmm...let's see if somebody else knows about it.
!
	else
		local qt quote(t)
		pcall ProjectNewWindow #qt
	endif
!
! Time to do it.
!
	local name getftext(ui$form, 'name')
	newwindow #name #nw_pd forcepd buttonmap #nw_bmap
	popdown #ui$form
endprocedure





define widget newconfig form 'New configs'
	noheader
	label l1 'New configuration name: '
	newline
	blank cname 'new' width 210
	newline
	label l2 'Copy from: '
	newline
	blank oldname variable dm$config width 210
	newline
	button help 'Help' command 'help ec-start'
	button doit 'Create Configuration' command 'DoConfigCreate'
	button cancel 'Cancel' command 'popdown #ui$form' color red
endform


procedure DoConfigCreate
	local cname getftext(ui$form,'cname')
	local ccopy getftext(ui$form,'oldname')
	newconfig #cname #ccopy
	popdown #ui$form
endprocedure


!
! The overall configuration editing widget
!
define widget ConfigEdit form 'config edit'
	noheader
	label l1 'Configuration Editing'
	newline
	button zap 'Zap' width 75 command 'popdown #ui$form' color red
	button help 'Help' width 75 command 'help editdconfig'
	newline
	button b1 'New Configuration' width 160 command 'popup newconfig'
	newline
	button b2 'New Window' width 160 command 'popup NewWindow'
	newline
	button b2a 'Delete Window' width 160 command 'popup ZorchWindow'
	newline
	button b3 'Save Configuration' width 160 command 'popup SaveConfig'
endform



!
! Definitions for the position entry widget.
!

define widget enter form "Entry widget"
	noheader
!
! The platform selection line.
!
	label l_plat "Platform:"
	pulldown platform 'n308d' menu 'plats' width 100
	label space ' ' width 100
	button exit 'Zap' color red command 'popdown #ui$form'
	newline
!
! Positions here.
!
	label l_lat 'Lat:'
	blank lat_deg '-9' width 40
	blank lat_min '-25' width 40
	label l_lon 'Lon:'
	blank lon_deg '159' width 40
	blank lon_min '58' width 40
	label l_alt 'Alt:'
	blank alt '0.0' width 60
	newline
!
! Let them put in a time.
!
	label l_time 'Time:'
	blank time 'now' width 200
	newline
!
! Options.
!
	button enter 'Enter point' command 'DoEnter false'
	button overw 'Change last point' command 'DoEnter true'
	newline
!
! And a gripe window.
!
	label gripe ' ' width 300 color red
endform


procedure DoEnter overwrite bool
!
! Pull info from the widget.
!
	local plat concat('l_',getftext(ui$form,'platform'))
	local lat_deg getftext(ui$form,'lat_deg')
	local lon_deg getftext(ui$form,'lon_deg')
	local lat_min getftext(ui$form,'lat_min')
	local lon_min getftext(ui$form,'lon_min')
	local alt getftext(ui$form,'alt')
! 
! Do the entry.
!
	if (overwrite)
		enter #plat #lat_deg #lat_min #lon_deg #lon_min #alt
	else
		local when getftext(ui$form,'time')
		enter #plat #lat_deg #lat_min #lon_deg #lon_min #alt #when
	endif
endprocedure




!
! Interface to the "kill" function.
!
define widget ZorchWindow form 'Window zapper'
	noheader
	label l1 'Delete a window.'
	newline
	label l2 'Enter window name below, or click on "select with mouse"'
	newline
	label l3 'to use the mouse.'
	newline
	label l4 'Window name:'
	blank victim '--' width 150
	button mouse 'Select with mouse' command 'ZW_pick'
	newline
	button help 'Help' command 'help ec-delete'
	button Reaper 'Do it' color red command 'ZW_Zap'
	button reprieve 'Cancel' command 'popdown #ui$form'
endform



!
! Select a victim with the mouse.
!
procedure ZW_pick
	set victim '--'
	pickwin victim
	formtext #ui$form victim #victim
endprocedure


!
! Do it.
!
procedure ZW_Zap
	local victim getftext(ui$form,'victim');
	kill #victim
	popdown #ui$form
endprocedure



!
! Standardized "put" routines.
!

!
! Put a fully-modified component out to a window.
!
procedure sendout comp string target string
!
! Get the target window if unspecified
!
	if (target = "pick")
		set target_win "none"
		pickwin target_win
		if (target_win = "none")	! They picked root or something
			beep
			return
		endif
	else
		set target_win target
	endif
!
! Figure out the proper positioning for this component.
!
	local rep pd_param(comp, comp, 'representation', 'string')
	if (rep = 'raster' or rep = 'filled-contour')
		local position '1'
	else
		local position '0'
	endif
!
! Now do it.
!
	sound chord
	add #comp #comp #target_win #position
endprocedure

procedure putc0 comp string
	sendout #comp 'pick'
endprocedure

procedure putc1 comp string param string value string
!
! Just mung in the parameter and ship it out.
!
	parameter #comp #comp #param #value
	sendout #comp 'pick'
endprocedure


procedure putc2 comp string p1 string v1 string p2 string v2 string
!
! Just mung in the parameter and ship it out.
!
	parameter #comp #comp #p1 #v1
	parameter #comp #comp #p2 #v2
	sendout #comp 'pick'
endprocedure


procedure putc3 comp string p1 string v1 string p2 string v2 string p3 string v3 string
!
! Just mung in the parameter and ship it out.
!
	parameter #comp #comp #p1 #v1
	parameter #comp #comp #p2 #v2
	parameter #comp #comp #p3 #v3
	sendout #comp 'pick'
endprocedure



!
! The dm equivalent for the require mechanism.  Tries to read
! the given file name (usually the command name) in the DmModPath
! directory.
!
procedure require cmd string

	if (not defined (concat ('ui$procedure_table:',cmd)))
		local fname concat3(dmmodpath,'/',cmd)
		message '	Trying to load #' fname
		set delayread 'read'
		#delayread #fname
	endif

endprocedure


!
! Code to connect PutScalar to skewt windows.
!
procedure sk-add-data platform string field string target string
!
! ISS compatibility: see if we need to append a "/omega" here.
!
	if (RealPlatform (concat (platform, '/omega')))
		local platform concat(platform, '/omega')
	endif
!
! Find the name of the second component (i.e. what we assume is the real
! data component).  Also check the overlay mode.
!
	local comp NthComp(target, 1)
	local mode PDParam(target,comp,'overlay-mode')
!
! If they are not in overlay mode just bash it in directly.  (Direct test
! on false since true is default)
!
	if (mode = 'false')
		parameter #target #comp platform #platform
		return
	endif
!
! OK implement overlaying for them.
!
	if (nvalue (target, comp, 'platform') >= 3)
		message 'Too many platforms.  Reset window to initial state.'
		beep
	else
		local explat PDParam(target,comp,'platform')
		if (explat = 'null')
		   	local explat platform
		else
			local explat concat3(explat, ',', platform)
		endif
		parameter #target #comp platform #explat
	endif
endprocedure



procedure ShipScalar platform string field string target_win string
!
! Start by figuring out if there is a special command for adding 
! to this window.  If there is, we just pass control off there and
! forget about it.
!
	local ptype PDParam(target_win, 'global', 'plot-type')
	local addcmd PDParam(target_win, 'global', 'add-data-command')
	if (addcmd = '(Undefined)')
		local qual concat(ptype,'-add-data-command')
		local addcmd PDParam('defaults','defaults',qual)
	endif
	if (addcmd <> '(Undefined)')
		require #addcmd
		#addcmd #platform #field #target_win
		return
	endif
!
! Now figure out what sort of window this is.
! If it's a CAP plot, send it out as a track (for now)
!
	if (ptype = 'CAP')
		parameter p_track p_track platform #platform
		parameter p_track p_track field #field
		sendout p_track #target_win
		return
	endif
	if (ptype = 'skewt')
		sk-add-data #platform #field #target_win
		return
	endif
!
! If it's NOT an xygraph, we don't know what to do.
!
	if (ptype <> 'xygraph')
		message 'I can not cope with plot-type "#"' ptype
		beep
		return
	endif
!
! OK.  Next step is to figure out if there is already a component out there
! which is displaying this field.
!
	local comps pd_complist(target_win)
	local found false
	local leftaxis true
	local ntrace 0
	foreach comp #comps
		local leftaxis (not leftaxis)
		if (comp <> 'global' and not found)
			local flds pd_param(target_win,comp,'y-field','string')
			if (flds = field)
				local ourcomp comp
				local found true
			endif
		endif
		local ntrace (ntrace + nvalue(target_win, comp, 'platform'))
	endfor
!
! If we found it, just add this info to it.
!
	if (found)
		parameter #target_win global plot-hold true
		local plats pd_param(target_win, ourcomp, 'platform', 'string')
		local plats quote(concat3(plats, ',', platform))
		parameter #target_win #ourcomp platform #plats
		local clrs pd_param(target_win,ourcomp,'field-color','string')
		local fcolor NthColor('xygraph', ntrace - 1)
		local clrs quote(concat3(clrs, ',', fcolor))
		parameter #target_win #ourcomp field-color #clrs
		parameter #target_win global plot-hold false
!
! Otherwise we need to add a new component.
!
	else
		set ntrace (ntrace + 1)
		parameter p_xytrace p_xytrace platform #platform
		parameter p_xytrace p_xytrace y-field #field
		if (leftaxis)
			parameter p_xytrace p_xytrace axis-left true
			parameter p_xytrace p_xytrace axis-right false
		else
			parameter p_xytrace p_xytrace axis-left false
			parameter p_xytrace p_xytrace axis-right true
		endif
		if (ntrace > 1)
			parameter p_xytrace p_xytrace axis-l-grid-intensity 0
		else
			parameter p_xytrace p_xytrace axis-l-grid-intensity 0.7
		endif
		local fcolor NthColor('xygraph', ntrace - 1)
		parameter p_xytrace p_xytrace 'field-color' #fcolor
		add p_xytrace p_xytrace #target_win
	endif
endprocedure




!
! Try to figure out what to do with a scalar field.
!
procedure PutScalar platform string field string
!
! Start by finding a window.
!
	set target_win "none"
	pickwin target_win
	if (target_win = "none")	! They picked root or something
		beep
		return
	endif
	ShipScalar #platform #field #target_win
endprocedure



!
! The old "print.widget" originating, I think, with the fest cdrom.
!
! Define a widget which collects hardcopy parameters, assembles them into
! a proper command using xwd, xpr, and xwd2ps, and executes the command 
! with 'shell'
!
! The following environemnt variables are checked to set defaults and
! get paths to executables:
!
! ZEB_PRINTER_NAME	-- Default name of printer, "lp" if not set
! ZEB_PRINTER_DEVICE	-- Default printer device, as it would appear in
!			   the pulldown menu label: ljet, pjet, ps, etc.
!			   "ps" if not set
! ZEB_XWD_PATH		-- Path to xwd.  "xwd" is used if environment
!			   variable not set.  The xwd program must exist
!			   somewhere else nothing will work.
! ZEB_XPR_PATH		-- Path to xpr, else "xpr" is used.  The xpr
!			   program is not needed if printing PS and
!			   xwd2ps can be found.  This program is needed
!			   if printing anything other than PostScript.
! ZEB_XWD2PS_PATH	-- Path to xwd2ps, else "xwd2ps" is used.  This 
!			   program is required to print Color PostScript,
!			   and in fact it is also the best alternative for
!			   grayscale monochrome.
!
! Note that options can be added to any of the program PATH variables, and the 
! options will be passed to the program.  For example, the PostScript page size
! used by xwd2ps can be changed with 
!
! setenv ZEB_XWD2PS_PATH 'xwd2ps -p A4'
!
! See the xwd2ps man page in cd/doc/man for details on all of the options.
! Also see the xwd(1) and xpr(1) man pages with the X distribution.  This
! depends on the xwd2ps executable supplied with the CD as that copy contains
! a bug fix.  Without it windows will not be oriented and scaled correctly.
!

set default_printer_name getenv("ZEB_PRINTER_NAME")
if (default_printer_name = "UNDEFINED")
	set default_printer_name "lp"
endif
set default_printer_device getenv("ZEB_PRINTER_DEVICE")
if (default_printer_device = "UNDEFINED")
	set default_printer_device "psmono"
endif


define widget hardcopy form "Print Window"

	noheader
	label title "HARDCOPY WIDGET" width 140 
	!
	! Command buttons
	!
	button help "Help" command 'help "printer"'
	button print "Print" command 'printer_go'
	button dismiss "Dismiss" command 'popdown #ui$form' color red
	newline
	label label_win "Printing:" width 140
	! menu might be useful if ever want to preselect window names
	! pulldown win "One Window" menu printer_window_menu width 150
	button win "One Window" command 'printer_toggle_win' width 150
	newline
	button label_name "Printer name:" command printer_toggle_dest width 140
	blank printer_name #default_printer_name width 150
	newline
	label label_device "Device type:" width 140
	pulldown printer_device #default_printer_device \
		menu printer_device_menu width 150
	newline
	label label_rv "Reverse video:" width 140
	button rv "On" command 'printer_toggle_rv' width 150
	newline
!	label label_orient "Orientation:" width 140
!	button orient "Portrait" command 'printer_toggle_orient' width 150
!	newline
	label label_remove "Remove widget:" width 140
	button remove "No" command 'printer_toggle_remove' width 150
	newline

	!
	! This label will be for showing instructions, hints, and errors
	!
	label hints1 "Verify/change settings, then click [Print]." \
		width 300 
	newline
	label hints2 "Be sure the window is not obstructed!" \
		width 300 

enddef


procedure printer_toggle_rv

	if (getftext(ui$form,"rv") = "Off")
		formtext #ui$form "rv" "On"
		formtext #ui$form "hints2" \
			"Black and white will be swapped."
	else
		formtext #ui$form "rv" "Off"
		formtext #ui$form "hints2" \
			"Black and white will not be swapped."
	endif

endprocedure


! Toggle output destination, printer or file
!
procedure printer_toggle_dest

	if (getftext(ui$form,"label_name") = "Printer name:")
		formtext #ui$form "label_name" "File name:"
		formtext #ui$form "hints2" \
			"Output will be sent to specified file."
	else
		formtext #ui$form "label_name" "Printer name:"
		formtext #ui$form "hints2" \
			"Output will be sent to named printer."
	endif

endprocedure


procedure printer_toggle_remove

	if (getftext(ui$form,"remove") = "No")
		formtext #ui$form "remove" "Yes"
		formtext #ui$form "hints2" \
			"Widget will disappear before printing."
	else
		formtext #ui$form "remove" "No"
		formtext #ui$form "hints2" \
			"Widget remains on screen while printing."
	endif

endprocedure


procedure printer_toggle_orient

	if (getftext(ui$form,"orient") = "Portrait")
		formtext #ui$form "orient" "Landscape"
		formtext #ui$form "hints2" \
			"Print window with landscape orientation."
	else
		formtext #ui$form "orient" "Portrait"
		formtext #ui$form "hints2" \
			"Print window with protrait orientation."
	endif

endprocedure


procedure printer_toggle_win

	if (getftext(ui$form,"win") = "One Window")
		formtext #ui$form "win" "Entire Screen"
		formtext #ui$form "hints2" \
			"The entire screen will be printed."
	else
		formtext #ui$form "win" "One Window"
		formtext #ui$form "hints2" \
			"The window to print will be picked by you."
	endif

endprocedure


define widget printer_window_menu intmenu "Window Selection"

	title "Window Selection"
	line
	entry "One Window" "formtext #ui$form window_option 'One Window'"
	entry "Entire Screen" "formtext #ui$form window_option 'Entire Screen'"

endmenu


define widget printer_device_menu intmenu "Printer Device Types"

	title "Device Types"
	line
	entry "Color PostScript" \
	   'pdevice "pscolor" "Color PostScript, using xwd2ps"' \
	   (getftext(ui$form,"printer_device") = "pscolor")
	entry "Monochrome PS" \
	   'pdevice "psmono" "Grayscale PostScript, using xwd2ps"' \
	   (getftext(ui$form,"printer_device") = "psmono")
	entry "HP LaserJet" \
	   'pdevice "ljet" "HP LaserJet, monochrome, needs xpr"' \
	   (getftext(ui$form,"printer_device") = "ljet")
	entry "HP PaintJet" \
	   'pdevice "pjet" "HP PaintJet, color, needs xpr"' \
	   (getftext(ui$form,"printer_device") = "pjet")
	entry "HP PaintJet XL" \
	   'pdevice "pjetxl" "HP PaintJet XL Color Graphics, color"' \
	   (getftext(ui$form,"printer_device") = "pjetxl")
	entry "Digital LA100" \
	   'pdevice "la100" "Digital LA100 selected, needs xpr"' \
	   (getftext(ui$form,"printer_device") = "la100")
	entry "Digital LN03" \
	   'pdevice "ln03" "Digital LN03 selected, needs xpr"' \
	   (getftext(ui$form,"printer_device") = "ln03")
	entry "IBM PP3812" \
	   'pdevice "pp" "IBM PP3812 selected, needs xpr"' \
	   (getftext(ui$form,"printer_device") = "pp")

endmenu


procedure pdevice dev_name string msg string

	local show_msg quote(msg)

	formtext #ui$form "printer_device" #dev_name
	formtext #ui$form "hints2" #show_msg

endprocedure


procedure printer_go

	set device_option getftext(ui$form,"printer_device")
	set rv_option " "
	set root_option " "
	set xwd2ps getenv("ZEB_XWD2PS_PATH")	
	set xwd getenv("ZEB_XWD_PATH")
	set xpr getenv("ZEB_XPR_PATH")
!
! Figure out what you have to run to get a file printed around here.
!
	if (SystemType = 'bsd')
		local pcommand '| lpr -P'
	else
		local pcommand '| lp -d '  ! trailing space necessary
	endif

	! Add a little robustness
	if (getftext(ui$form,"printer_name") = "")
		formtext #ui$form "hints2" \
			"No destination name specified. Try again."
		return
	endif

	if (xwd = "UNDEFINED")
		set xwd "xwd"
	endif
	if (xpr = "UNDEFINED")
		set xpr "xpr"
	endif

	if (getftext(ui$form,"win") = "Entire Screen")
		set root_option " -root "
		formtext #ui$form "hints1" \
			"Printing the entire screen, please wait."
	else
		formtext #ui$form "hints1" \
			"Click mouse in window you wish printed."
	endif

 	set print_command concat3(xwd,root_option," | ")

	!
	! If the device is "pscolor", we must try xwd2ps.
	! If the device is "psmono", we will use xwd2ps since
	! its being supplied on the CD.
	! Every other device has to go to xpr.
	!
	if ((device_option = "pscolor") or (device_option = "psmono"))
		if (getftext(ui$form,"rv") = "On")
			set rv_option " -I "
		endif
		if (xwd2ps = "UNDEFINED")
			set xwd2ps "xwd2ps"
		endif
		set print_command concat(print_command,xwd2ps)
		set print_command concat(print_command,rv_option) 
		if (device_option = "psmono")
			set print_command concat(print_command," -m ")
		endif
	!
	! Otherwise we're printing to a non-PS device and must use xpr
	!
	else
		if (getftext(ui$form,"rv") = "On")
			set rv_option " -rv "
		endif
		set print_command concat3(print_command,xpr,rv_option)
		! Not necessary but we'll keep it for posterity
		if (device_option = "psmono")
			set device_option "ps"
		endif
		set print_command concat3(print_command," -device ",device_option)
	endif

	!
	! Now test destination: either a file or a printer
	!
	if (getftext(ui$form,"label_name") = "Printer name:")
		set print_command concat(print_command, pcommand)
	else
		set print_command concat(print_command," > ")
	endif
	set print_command concat(print_command,getftext(ui$form,"printer_name"))
	message "Print command: #" print_command

	set show_print_command quote(print_command)
	formtext #ui$form "hints2" #show_print_command
	if (getftext(ui$form,"remove") = "Yes")
		popdown #ui$form
		shell print_command
	else
		shell print_command
		formtext #ui$form "hints1" "Done. [Print] again or change settings."
		formtext #ui$form "hints2" "Click [Dismiss] to remove this window."
	endif
endprocedure






!
! Stuff for the old "create window" widget.
!
define widget pd-menu intmenu 'PD Templates'
	title 'Select a Plot Description'
	line
	entry 'Constant altitude plot' 'cw_setpd cap-template'
	entry 'Time-series plot' 'cw_setpd tseries-template'
	entry 'Skew-t plot' 'cw_setpd skewt-template'
	entry 'Wind profile' 'cw_setpd wind-template'
endmenu



procedure cw_setpd pd string
	formtext #ui$form pdname #pd
endprocedure

	
define widget bmap-menu intmenu 'Button Maps'
	title 'Select a Button Map'
	line
	entry 'Basic'		'formtext #ui$form bmap "basic"' 
	entry 'Radar'		'formtext #ui$form bmap "radar"' 
	entry 'Sounding'	'formtext #ui$form bmap "sounding"'
	entry 'Time series'	'formtext #ui$form bmap "xyplot"'
endmenu

!
! Window creation.
!
define widget OldNewWindow form 'Window creation'
	noheader
	label l1 'New window name:  '
	blank wname '--' width 190
	newline
	label l2 'Plot description: '
	blank pdname 'cap-template' width 190
	newline
	label l5 'Button map:       '
	blank bmap 'default' width 190
	newline
	pulldown pdlist 'Plot Descriptions ->' menu 'pd-menu'
	pulldown bmaps 'Button Maps ->' menu 'bmap-menu'
	newline 
	label l3 'PD Force?'
	button forcepd 'no' command 'ToggleFormButton forcepd' width 40
!	newline
	label l4 '    '
	button doit 'Create Window' color red command 'DoOldWindowCreate'
	button cancel 'Cancel' command 'popdown #ui$form' color red
endform

procedure ToggleFormButton button string
	local current getftext(ui$form,button)
	if (current = 'yes')
		formtext #ui$form #button 'no'
	else
		formtext #ui$form #button 'yes'
	endif
endprocedure

!
! Perform the actual window creation.
!
procedure DoOldWindowCreate
!
! Get the info out of the form.
!
	local name quote(getftext(ui$form,"wname"))
	local pdname getftext(ui$form,"pdname")
	local bmap getftext(ui$form,"bmap")
	local forcepd getftext(ui$form,"forcepd")
!
! Make sure they gave a name.
!
	if (name = '"--"')
		beep
		return
	endif
!
! Get the forcepd flag right.
!
	if (forcepd = "yes")
		local forcepd 'forcepd'
	else
		local forcepd ' '
	endif
!
! Create the window.
!
	newwindow #name #pdname #forcepd buttonmap #bmap
	popdown #ui$form
endprocedure


!
! A little tweaker that gets endpoints to all cross section windows.
!
procedure AllXSect x0 string y0 string x1 string y1 string
	windowlist wins
	foreach window #wins
		local pt PDParam(window, 'global', 'plot-type')
		if (pt = 'xsect')
			local ep1 quote(concat3(x0, ',', y0))
			local ep2 quote(concat3(x1, ',', y1))
			parameter #window global plot-hold true
			parameter #window global left-endpoint #ep1
			parameter #window global right-endpoint #ep2
			parameter #window global plot-hold false
		endif
	endfor
endprocedure
