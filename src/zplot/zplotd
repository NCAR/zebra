#! /usr/local/bin/perl5
#
# Sit and wait for notifications on platforms, and send a plot
# to JOSS for each notification.
#

# Use an associative array to give the config and window to plot
# when a given platform is updated.

$D_Out  = 1;    # Just pipe log output to stdout as well as to file
$D_NoFtp = 2;   # Skip ftp
$D_NoPlot = 3;  # Skip batch plot and ftp
$D_NoEmail = 4; # Don't email

$debug = 0;		     	# No debugging
$FAIL = "ZPLOTD_FAILED";	# failure string

$image_mail_list = " granger ";

$ENV{'LD_LIBRARY_PATH'} = "/local/X11R6/lib:/usr/local/lib";
$ENV{'ZEBRA_SOCKET'} = "/tmp/zebra.forestabl";
$ENV{'ZEB_TOPDIR'} = "/scr/steam/granger/zebra";

# Top zebra directory
$ztop=$ENV{'ZEB_TOPDIR'};
$zbin="$ztop/bin";
$ENV{'PATH'} = "$zbin:" . $ENV{'PATH'};

# Project directory
$project = `pwd`;
chop $project;

# The platforms which are plotted for each observation rather
# than only the most recent
%Observations = ("iss2/class", 1, "iss3/class", 1, "iss4/class", 1);

%Plots = (
	  "iss2/class", 	"iss2 class",
	  "iss2/prof915h",	"iss2 prof915l",
	  "iss2/rass915",	"iss2 rass",
	  "iss2/surface_met",	"iss2 surfmet surfwind surfrad",

	  "iss4/class", 	"iss4 class",
	  "iss4/prof915h",	"iss4 prof915l",
	  "iss4/rass915",	"iss4 rass",
	  "iss4/surface_met",	"iss4 surfmet surfwind surfrad"
	  );

@Queue = ();
@Targets = ();
%Pending = ();		# Platforms already in queue
%Displays = ();

# Default to getting notifications from standard input
$since = 0;		# Plot only data since a given timestamp
$notice = 0;		# Plot data as notices received from dsnotice
$first = 0;		# true when platforms were queued from the cmd-line

# If we we're passed platform names or regular expressions on the
# command line, just do those
while ($pattern = shift @ARGV)
{
    if ($pattern eq "-since")
    {
	$since = shift @ARGV;
	$since = " " unless ($since);
	next;
    }
    if ($pattern eq "-notice")
    {
	$notice = 1;
	next;
    }
    if ($pattern eq "-time")
    {
	$fixtime = 1;
	$fixbegin = shift @ARGV;
	$fixend = shift @ARGV;
	next;
    }
    if ($pattern =~ /^-d(\d*)/)
    {
	if ($1) 
	{
	    $debug = $1;
	}
	else
	{
	    ++$debug;
	}
	next;
    }
    foreach $platform (keys(%Plots))
    {
	if ($platform =~ /$pattern/)
	{
	    $first = 1;
	    if (! $Pending{$platform})
	    {
		$entry = join(' ', ($platform, "now", $Plots{$platform}));
		push (@Queue, $entry);
		push (@Targets, $platform);
		$Pending{$platform} = 1;
	    }
	}
    }
}
print STDERR "Debug level = $debug\n" if $debug;
print STDERR "Queueing: \n   ",
    join("\n   ",@Queue), "\n" unless (! $first);

# The target platform plots default to all of them
if (! @Targets) { @Targets = keys(%Plots); }

# If we weren't told to get input elsewhere, then
# just clear the queue and we're done
if ($first && ! $since && ! $notice && ! $fixtime)
{
    &clear;
    exit 0;
}

$dt = `date -u '+%y%m%d.%H%M'`;
chop $dt;
$log="$project/logs/zplotd.$dt.log";
if ($debug >= $D_Out)
{
    open(LOG, "| tee $log") || die "$log : $!\n";
}
else
{
    open(LOG, "> $log") || die "$log : $!\n";
}
select LOG;
$| = 1;
open(STDOUT, ">& LOG") || die "could not redirect stdout: $!\n";
open(STDERR, ">& LOG") || die "could not redirect stderr: $!\n";
print "Log file: $log\n";
$EL = "true";
#$EL = "$zbin/EventLogger -n -l epic -f logs/zebra.$dt.log";

# Make sure zebra is running; usually it should already be running
if (system("ZEB_TOPDIR=\"$ztop\" ZEB_EVENTLOGGER=\"$EL\" $zbin/zstart -n -ds -preserve -data /net/sssf2/forestabl $project"))
{
    die "Failed to start zebra.\n";
}
sleep 5;

# Request a rescan to check for new data files; we shouldn't need to wait
# for the rescan to finish, since later queries of the daemon should just
# block until the rescan is done.

!system("dsrescan -all") || print "*** dsrescan failed ***";
sleep 15;

$timeout = 30;

# Open our source for platform and file notices
if ($since)
{
    $until = "$since.update";
    # If we're only plotting since a given time, get our platform list from 
    # the dfsince script.
    print "Opening dfsince $since ...\n";
    open (DS, "dfsince $since 2> /dev/null |") || 
	die "dfsince: $!";
    $timeout = 0;
}
elsif ($notice)
{
    # Open a dsnotice session and read the output
    $targets = join(' ',@Targets);
    print "Opening $zbin/dsnotice -dir $targets ...\n";
    open (DS, "$zbin/dsnotice -dir $targets 2>&1 |") || 
	die "dsnotice: $!";
}
elsif ($fixtime)
{
    # Get a list of platforms to plot with data within the given time
    # period.
    $targets = join(' -e ',@Targets);
    print "Running $zbin/dsdump -l -p $fixbegin -p $fixend -e $targets...\n";
    open (DS, "$zbin/dsdump -l -p $fixbegin -p $fixend $targets |") ||
	die "dsdump: $!";
}
else
{
    # Just use standard input
    print "Opening -\n";
    open (DS, "-") || die "stdin: $!";
}


$SIG{'ALRM'} = 'clear';

while (<DS>)
{
	next if /Receiving/;	# Skip dsnotice start-up line

	# Remove any elog verbosity
	s/^.*Notice-\S+ //g;
	# Decipher the line
	($platform, $file, $dir, $time, $nsample) = split(/\s+/,$_);
	print "$platform $file $time $nsample" if ($debug);

	# If not in our list of plots, ignore it
	if (defined $Plots{$platform} &&
	    ($Observations{$platform} || ! $Pending{$platform}))
	{
	    $Pending{$platform} = 1;

	    # This latest notify will overwrite any notifications for this
	    # platform already in the queue
	    $entry = join(' ', ($platform, $time, $Plots{$platform}));
	    push (@Queue, $entry);

	    # After adding to the queue, set the alarm to clear the queue
	    # after a suitable timeout with no further notifications.
	    alarm($timeout);
	    
	    print " ...queued\n" if ($debug);
	}
	else
	{
	    print " ...skip\n" if ($debug);
	}
}
print "Input exhausted.\n" if $debug;
close DS;

# Clear anything left in the queue
&clear;

# Now we can update the times to which we've plotted
# move $until into $since

# Make sure we exit, even if it means aborting a hang
$SIG{'ALRM'} = 'exit';
alarm(30);

# For some reason STDOUT and STDERR must be closed before LOG can close,
# else perl hangs.  It might be because they have been redirected to LOG.
close STDOUT;
close STDERR;
close LOG;

exit 0;

sub clear
{
    $result = 1;
    alarm(0);
    print "Clearing queue...\n" if $debug;

    if ($#Queue < 0)
    {
	print "clear: No platforms in queue.\n";
	return 1;
    }

    $dt = `date -u '+%y%m%d.%H%M'`;
    chop $dt;
    $plog="$project/logs/plot.$dt.log";
    open(PLOG, "> $plog") || die "could not open $plog: $!\n";
    $oldfh = select(PLOG); $| = 1; select($oldfh);

    # Map the platforms in the queue into an array
    # of display configs and windows
    #foreach $entry (@Queue)
    #{
    #   ($platform, $time) = split(/\s+/,$entry);
    #    ($config, @window) = split(/\s+/,$Plots{$platform});
    #    print "$platform $time --> " .
    #	"$config " . join(" ",@window) . "\n";
    #    print PLOG "$platform $time --> " .
    #	"$config " . join(" ",@window) . "\n";
    #    foreach $w (@window)
    #    {
    #	if (index($Displays{$config},"$w") < 0)
    #	{
    #	    $Displays{$config} .= " $w ";
    #	}
    #    }
    #}

    # Finally we can plot each config and its windows
    # Open batch-plot and pipe our plot entries to it

    $images = "";
    $status="ok";
    $batch = "/tmp/zplotd.batch.$$";
    print "Opening $batch...\n" if $debug;
    if (! open (BATCH, "> $batch"))
    {
	$status="$FAIL $batch: $!";
	print "$status" if $debug;
	return 0;
    }
    foreach $entry (@Queue)
    {
	($platform, $time, $config, @window) = split(/\s+/,$entry);
	if ($fixtime) { $time = $fixend; }
	$plot = "$time $config " . join(" ",@window);
	print "$plot\n";
	print PLOG "$plot\n";
	print BATCH "$plot\n";
    }
    close BATCH;
    print "Running: sh -x ./batch-plot - < $batch\n";
    if ($debug < $D_NoPlot)
    {
	if (! open (BP, "sh -x ./batch-plot - < $batch 2>&1 |"))
	{
	    $status="$FAIL batch-plot: $!";
	    print "$status" if $debug;
	    return 0;
	}
	while (<BP>)
	{
	    print;
	    print PLOG;
	    if (/^Images: (.*)$/)
	    {
		$images .= " $1 ";
	    }
	}
	close BP;
	$status = "$FAIL" if ($?);
    }
    unlink("$batch");
    print "Running: ftpjoss.pl $images\n" unless ($D_NoFtp);
    if ($D_NoFtp)
    { }
    elsif (open (FTP, "ftpjoss.pl $images 2>&1 |"))
    {
	while (<FTP>)
	{
	    print;
	    print PLOG;
	}
	close FTP;
	if ($?) {
	    $status = "$FAIL";
	    $result = 0;
	}
    }
    else
    {
	$status="$FAIL: ftp";
	$result = 0;
    }

    close PLOG;
    $cmd = "elm -s \"zplotd $status, log $plog\" " .
	" $image_mail_list >/dev/null";
    print "$cmd\n";
#   if ($debug < $D_NoEmail && ! open (MAIL, "| cat - $plog | $cmd"))
    if ($debug < $D_NoEmail && ! open (MAIL, "| cat - | $cmd"))
    {
	print "*** Mail failed! ***\n";
    }
    elsif ($debug < $D_NoEmail)
    {
	print MAIL "Images:\n";
	$images =~ s/^\s+//;
	foreach $i (split(/\s+/,$images))
	{
	    $url = $i;
	    $url =~ s,/net/global/www,, ;
	    print MAIL "http://www.atd.ucar.edu$url\n";
	}
	print MAIL "\n";
	print MAIL "Log files:\n";
	print MAIL "file:$log\n";
	print MAIL "file:$plog\n";
	print MAIL "\n";
	close MAIL;
	print "--- Mail sent. ---\n";
    }
    @Queue = ();
    %Pending = ();
    %Displays = ();
    return $result;
}



