#! /usr/bin/sh
#
# $Id: zplotbatch,v 1.14 1999-10-20 02:10:04 granger Exp $
#
# Start a display manager session with a virtual X server and dump
# images of its plots.

# Set to 'echo' to debug rather than actually dump images
echo=

# Path to Xvfb
xvfb="Xvfb"

if [ x$BATCH_IMAGE_SPOOL = x ]; then
    echo "Batch image spool directory not set: BATCH_IMAGE_SPOOL"
    echo "This script probably needs to be run with 'zconfig'."
    exit 1
fi

spool="$BATCH_IMAGE_SPOOL"

# Display connection to use for virtual X server
display=":9"

# Get a time
when=""
if [ $# -gt 0 ]; then
    when=$1
    shift
    case $when in
     *-*-*,*:*) 
	;;
     now) 
	;;
     -)
	echo "Accepting plots from stdin"
	;;
     *)
	when=""
	;;
    esac
else
    # Time defaults to now
    when=now
fi

# The only argument we really check is the first one
if [ "x$when" = "x" ]; then
    echo "Usage: $0 [ {now|<time>} config [window ..]]"
    echo "First argument, if present, must be 'now' or a time:"
    echo "$0 now [config] [window ..]"
    echo "$0 3-Dec-97,22:06:03 [config] [window ..]"
    echo "'now' is the default time."
    echo "A single argument of - accepts arguments from standard input:"
    echo "$0 -"
    echo "When reading stdin, lines are '{now|<time>} config [window ..]'"
    exit 1
fi

# Get a config
config=''
if [ $# -gt 0 ]; then
    config=$1
    shift
fi

# Get a window list
windows=''
while [ $# -gt 0 ]; do
    windows="$windows $1"
    shift
done

if [ "x$when" != "x-" ]; then
    temp=/tmp/batch-plot.$$
    echo "$when $config $windows" > $temp
    exec < $temp
fi

# Start our private, virtual X display.
# This may fail if one is already there, in which case we'll use the
# existing one.  Either way, disable access control so that others can
# connect to it no matter who starts it.

$xvfb $display >/dev/null 2>&1 &
x=$!
sleep 5
DISPLAY=${display}.0 ; export DISPLAY
xhost +

# Make sure we have a datastore running; we don't need the event logger
ZEB_EVENTLOGGER=true ; export ZEB_EVENTLOGGER

echo "-- Checking for datastore session:"
zstart -n -preserve -ds $ZEB_PROJDIR
sleep 1

# Then start a private display session
# We set the dm name explicitly so that we can query it

DEFAULT_CONFIG=empty
DM=B$$
ZEB_DM_CONFIG="-multiple -name $DM dm.config"
export DEFAULT_CONFIG ZEB_DM_CONFIG
echo "-- Starting display manager:"
zstart -dm -preserve $ZEB_PROJDIR >/dev/null 2>&1 &
dm=$!
sleep 10
# Wait for dm to connect to datastore, then wait for dm to respond to
# a query once daemon scan finally finishes
if zquery -t 600 $DM > /dev/null 2>&1; then true ; else
    echo "$DM display never connected."
    exit 1
fi

images=''
lastconfig=''
now=`zquery timer | egrep 'Current time' | sed -e 's/^.*is //'`
echo "Current time: $now"

# Begin looping over the plots we're supposed to make
while read when config windows; do

    echo "Processing: $when $config $windows"

    if ($config != $lastconfig)
    {
	(set -x; zrun $DM "display $config")
	sleep 20
	$lastconfig = $config;
    }
    if [ $when = "now" ]; then
    	zrun $DM "realtime all"
	when=$now
    else
    	zrun $DM "history all $when"
    fi
    # Wait for windows to take the new time.  Apparently a window might
    # actually respond to an imgdump command before it has received or
    # acted on the time change, so we must delay here until the time
    # takes effect.
    sleep 20

    # Get a list of the graphics processes appearing in this display
    # mstatus
    procs=`mstatus | egrep "group-$DM" | sed -e 's,^.*:,,g' -e 's/,//g'`
    echo "Processes: $procs"

    # For each process, tell it to dump its plot

    # JOSS filenames: platform.YYYYMMDDHHmm.plottype.{jpg,gif}
    # We're sticking with gif for now
    # Derive the image name from the plot time
    set `ztsplit $when`
    base="${config}.$1$2$3$4$5."
    # For the Web, put the images in directories by date, lumping
    # images from all instruments into the same directory.
    subspool="${spool}/$1$2$3"
    echo "Putting images in $subspool"
    if [ ! -d $subspool ]; then
	mkdir -p $subspool
    fi

    queryprocs=''
    for plot in $procs ; do

	win=`echo $plot | sed -e "s/-$DM.*//"`

	# If we have specific targets, skip this window if it's not one of them
	if test "$windows" = "" || echo "$windows" | egrep -s "$win"; then

	    name="$subspool/${base}${win}.gif"
	    /bin/rm -f "$name"

	    # Form the gif file name by extracting the plot name from the
	    # process. An alternative is to grep the pd-name from a zquery of
	    # the process, which includes the config name.  For now we can
	    # prepend the config here.

	    images="$images $name"
	    (set -x; zrun $plot "imgdump gif \"$name\"" ; set +x ; sleep 5 ; \
	     zquery -t 30 $plot >/dev/null ; disclaim $name) &
	    queryprocs="$queryprocs $plot"

	fi

    done
    # Now make sure each imgdump has finished before possibly switching
    # to another display configuration.  This is our re-synch or rendezvous
    # of all the background parallel image dumps.  disclaim may still be
    # running on the images, but we're through with those files.  The sleep
    # is to give the windows time to actually start the dumps, so that
    # our query doesn't succeed *before* the imgdump command is received.
    echo "Waiting for windows to finish image dumps..."
    sleep 5
    for plot in $queryprocs ; do
        (set -x; zquery -t 30 $plot > /dev/null)
    done
    echo "Window dumps finished."

done

if [ -f "$temp" ]; then
    rm -f $temp
fi

# Exit the window manager, give it a little time to shutdown before
# outrightly killing it
(set -x; zrun $DM 'shutdown')
sleep 10
kill $dm

# We'd kill our virtual X server, but another batch-plot may be using it
# kill $x

# Kill the server if no one else is using it
#if [ `xlswins -display $display | wc -l` -lt 2 ]; then
#    kill `ps -e | grep Xvfb | grep -v grep | awk -e '{ print $1; }'`
#    # Give the server time to die and clear its socket
#fi

# Pass on the image file names in sorted order
echo Images: `(for img in $images DONE ; do
		if [ $img != "DONE" ]; then
		    echo $img
		fi
	       done) | sort`

# The shell will automatically 'wait' for its background jobs
# to finish before exiting, which means all the disclaimers should
# be done.
exit 0
