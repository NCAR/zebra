/* -*- C -*-
 * Imakefile for the DataStore
 */

MFVERSION="$Id: Imakefile,v 1.68 1998-05-05 14:52:19 burghart Exp $"

DEPLIBS=$(ZLIBS)
LIBMPROF=/dt/granger/libc_mp.a
/* SYSLIBS= $(LIBMPROF) */

/*
 * Defines for the sweepfile stuff.
 */

DMNSYSLIBS=$(LIBREGEXP) $(LIBMATH) $(LIBTERMCAP)
DMNLIBS=$(ZLIBS) $(XLIBS) $(LIBNETCDF) $(LIBHDF) $(LIBUDUNITS) $(LIBSWF)
SYSLIBS=$(LIBREGEXP) $(LIBMATH)
LIBS=$(ZLIBS) $(LIBNETCDF) $(LIBHDF) $(LIBUDUNITS) $(LIBSWF)

DEBUGGER = xgdb
#ifdef DebugFlag
DEBUG = -DDEBUG -DNoBuffer -DDEBUGGER="\"$(DEBUGGER)\""
#endif
DEFINES = $(DEBUG) /* -DNCSYNC_FIXED */


/*
 * Data File Access modules
 */
DFAOBJS = DataFormat.o DFA_NetCDF.o DFA_Zebra.o DFA_HDF.o DFA_Grads.o \
          DFA_Boundary.o DFA_GRIB.o GRIB.o DFA_Raster.o Raster.o DFA_None.o \
          DFA_SweepFile.o
DFASRCS = DataFormat.c DFA_NetCDF.c DFA_Zebra.c DFA_HDF.c DFA_Grads.c \
          DFA_Boundary.c DFA_GRIB.c GRIB.c DFA_Raster.c Raster.c DFA_None.c \
	  DFA_SweepFile.cc

/* 
 * DCOBJS, DCSRCS =  data chunk modules 
 */
DCOBJS = DataChunk.o DataAttr.o dc_Boundary.o dc_IRGrid.o dc_Image.o \
	 dc_MetData.o dc_MetAttr.o dc_RGrid.o dc_Scalar.o dc_Transp.o \
	 dc_TrAttr.o dc_Attr.o dc_Location.o dc_NSpace.o dc_Process.o \
	 dc_Elements.o dc_ADE.o dc_All.o Details.o dc_Polar.o
DCSRCS = DataChunk.c DataAttr.c dc_Boundary.c dc_IRGrid.c dc_Image.c \
	 dc_MetData.c dc_MetAttr.c dc_RGrid.c dc_Scalar.c dc_Transp.c \
	 dc_TrAttr.c dc_Attr.c dc_Location.c dc_NSpace.c dc_Process.c \
	 dc_Elements.c dc_ADE.c dc_All.c Details.c dc_Polar.c

/*
 * Modules shared between client library and daemon
 */
SHAREDOBJS = $(DFAOBJS) $(DCOBJS) d_Notify.o Platforms.o ds_fields.o Field.o
SHAREDSRCS = $(DFASRCS) $(DCSRCS) d_Notify.c Platforms.c
SHAREDSRCS_CXX = ds_fields.cc Field.cc


/* 
 * DSOBJS, DSSRCS = Daemon-specific object modules 
 */
DSOBJS = Daemon.o d_DataTables.o d_Config.o d_Scan.o d_Debug.o d_Appl.o
DSSRCS = Daemon.c d_DataTables.c d_Config.c d_Scan.c d_Debug.c d_Appl.c

/* 
 * DSLIBOBJS, DSLIBSRCS = normal DS library code 
 */
DSLIBOBJS = Appl.o DFA_Appl.o SA_Appl.o C_Appl.o ingest.o GetList.o \
	    ds_Derive.o DerivNode.o DerivTable.o FDScan.o FDParse.tab.o \
	    $(SHAREDOBJS) 
DSLIBSRCS = Appl.c DFA_Appl.c SA_Appl.c C_Appl.c ingest.c GetList.c \
	    $(SHAREDSRCS)
DSLIBSRCS_CXX = ds_Derive.cc DerivNode.cc DerivTable.cc FDScan.cc \
	        FDParse.tab.cc $(SHAREDSRCS_CXX)


UTILSRCS = rfdump.c zfdump.c GRIBdump.c bfdump.c

/*
 * Text file of default derivation definitions
 */
DERIVDEF = Derivations

/*
 * For debugging and testing.  Note that T_HDF is a standalone program, 
 * so there's no T_HDF.o in TESTOBJS.
 */
TESTSRCS = aline.c apple.c T_HDF.c \
	   T_Appl.c T_Attr.c T_DataChunk.c T_DataFormat.c T_DataStore.c \
	   T_Derivations.c T_Fields.c T_Grids.c T_MetData.c T_NetCDF.c \
	   T_NSpace.c T_Scalar.c T_Transparent.c T_Utils.c T_ZNF.c

TESTOBJS = T_Appl.o T_Attr.o T_DataChunk.o T_DataFormat.o T_DataStore.o \
	   T_Derivations.o T_Fields.o T_Grids.o T_MetData.o T_NetCDF.o \
	   T_NSpace.o T_Scalar.o T_Transparent.o T_Utils.o T_ZNF.o

/*
 * The complete set of modules for linking test programs.  Some test
 * objects supercede the normal library objects, so order is important.
 */
TESTMODS = $(TESTOBJS) ./libZebraDS.a

/*
 * All of the sources in this directory, for the make depend.
 */
SRCS = $(DSLIBSRCS) $(DCSRCS) $(DSSRCS) $(UTILSRCS)
SRCS_CXX = $(DSLIBSRCS_CXX)

PRIVATE_HEADERS = BoundaryFile.h DataChunkP.h dslib.h znfile.h \
		  RasterFile.h commands.h dfa.h dsDaemon.h dsPrivate.h \
		  GRIB.h Appl.h DataFormat.h Platforms.h apple.h GetList.h \
		  DerivNode.h DerivTable.h Field.h

HEADERS = DataStore.h DataChunk.h ingest.h ds_fields.h

DSCONFIGS = perm.config aline.config apple.config

DISTFILES = Imakefile $(SRCS) $(PRIVATE_HEADERS) $(TESTSRCS) \
            $(HEADERS) Daemon.state hdflook.c $(DSCONFIGS) dbgstart.csh \
	    $(DERIVDEF)

DEPEND_DEFINES=$(HDFDEFINES) $(HDFINCLUDES) $(NETCDFINCLUDES) $(RDSSINCLUDES)

/*
 * The daemon
 */
DMNOBJS = $(DSOBJS) $(SHAREDOBJS)
CccProgramTarget(dsDaemon,$(DMNOBJS),$(DEPLIBS),$(DMNLIBS),$(DMNSYSLIBS))

SpecialObjectRule($(DSOBJS),/**/,$(RDSSINCLUDES))

UILoadFileTarget(dsDaemon.lf,Daemon.state)

/*
 * Make the library.
 */
NormalLibraryTarget (ZebraDS, $(DSLIBOBJS))
SpecialObjectRule(ingest.o,ingest.c ingest.h,$(RDSSINCLUDES))
SpecialObjectRule(DFA_NetCDF.o T_NetCDF.o,DFA_NetCDF.c,$(NETCDFINCLUDES))
SpecialObjectRule(DFA_HDF.o T_HDF.o,DFA_HDF.c,$(HDFDEFINES) $(HDFINCLUDES))
SpecialCplusplusObjectRule(Fields.o,Fields.cc,$(UDUNITSINCLUDES))
SpecialCplusplusObjectRule(DFA_SweepFile.o,DFA_SweepFile.cc,$(SWFDEFINES) $(SWFINCLUDES))

InstallLibrary (ZebraDS, $(LIBDIR))
InstallNonExecFile ($(DERIVDEF), $(LIBDIR))

install::
	(cd $(LIBDIR); $(RM) libZebDS.a; $(LN) libZebraDS.a libZebDS.a)

BuildIncludesTop($(HEADERS))
InstallMultipleFlags($(HEADERS),$(INCDIR),$(INSTINCFLAGS))

/*
 * Dump routines.
 */
RFDOBJS = rfdump.o Raster.o
CompleteProgramTarget (rfdump,$(RFDOBJS),$(LIBZEBRA),$(LIBZEBRA),/**/)

TestProgramTarget (bfdump, bfdump.o, $(LIBZEBRA), $(LIBZEBRA), /**/)

ZFOBJS = zfdump.o ./libZebraDS.a
CccProgramTarget (zfdump,$(ZFOBJS),$(DEPLIBS),$(LIBS),$(LIBREGEXP) $(LIBMATH))

GDOBJS = GRIBdump.o GRIB.o
CompleteProgramTarget(GRIBdump,$(GDOBJS),$(LIBZEBRA),$(LIBZEBRA),$(LIBMATH))

/* 
 * Special stuff for the field derivation flex scanner/bison parser code.  The
 * depend:: target assures that FDScan.cc and FDParse.tab.cc get built before 
 * we generate the dependency list. 
 */
FDScan.cc: FDScan.flex FDParse.tab.h
	flex -t -PFD FDScan.flex > FDScan.cc
	$(CP) -f $@ $@.dist

FDParse.tab.h: FDParse.tab.cc
	$(CP) -f $@ $@.dist

FDParse.tab.cc: FDParse.bison
	bison -p FD -d --file-prefix=FDParse FDParse.bison
	$(MV) FDParse.tab.c FDParse.tab.cc
	$(CP) -f $@ $@.dist

depend:: FDScan.cc FDParse.tab.cc


/*
 * Test routines.
 */
#if HasHDF
TestProgramTarget (hdflook, hdflook.o, /**/, $(LIBHDF), /**/)
SpecialObjectRule (hdflook.o, hdflook.c, $(HDFINCLUDES))
#endif

APOBJS = apple.o $(TESTMODS)
CccTestProgramTarget (apple, $(APOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

#ifdef notdef
TestProgramTarget (nctime, nctime.o, /*DEPLIBS*/, $(LIBNETCDF), /**/)
SpecialObjectRule(nctime.o,/**/,$(NETCDFINCLUDES))
#endif

#ifdef NETCDF31
NC31DIR = /net/src/data-tools/netcdf-3.1a/gcc-g/include
NC31LIB = /net/src/data-tools/netcdf-3.1a/gcc-g/lib/libnetcdf.a
NC24DIR = /net/src/data-tools/netcdf-2.4-beta2/gcc-O/include
NC24LIB = /net/src/data-tools/netcdf-2.4-beta2/gcc-O/lib/libnetcdf.a

apple31: $(APOBJS) $(DEPLIBS) FORCE
	rm -f apple DFA_NetCDF.o
	$(MAKE) apple LIBNETCDF=$(NC31LIB) NETCDFINCLUDES=-I$(NC31DIR)
	mv apple apple31

apple31.tc: $(APOBJS) $(DEPLIBS) FORCE
	rm -f apple DFA_NetCDF.o
	$(MAKE) apple.tc LIBNETCDF=$(NC31LIB) NETCDFINCLUDES=-I$(NC31DIR)
	mv apple.tc apple31.tc

nctime31: nctime.o FORCE
	rm -f nctime.o
	$(MAKE) nctime LIBNETCDF=$(NC31LIB) NETCDFINCLUDES=-I$(NC31DIR)
	mv nctime nctime31

apple24: $(APOBJS) $(DEPLIBS) FORCE
	rm -f apple DFA_NetCDF.o
	$(MAKE) apple LIBNETCDF=$(NC24LIB) NETCDFINCLUDES=-I$(NC24DIR)
	mv apple apple24

nctime24: nctime.o FORCE
	rm -f nctime.o
	$(MAKE) nctime LIBNETCDF=$(NC24LIB) NETCDFINCLUDES=-I$(NC24DIR)
	mv nctime nctime24

FORCE:
#endif

ALOBJS = aline.o ./libZebraDS.a
CccTestProgramTarget (aline, $(ALOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

test:: dbgstart

dbgstart: dbgstart.csh
	$(RM) $@
	sed -e s,##TOPDIRHERE,BaseDir, < dbgstart.csh > $@
	chmod +x $@

clean::
	rm -f dbgstart

#ifdef notdef
THDFOBJS = T_HDF.o ./libZebraDS.a
TestProgramTarget (testhdf, $(THDFOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))
#endif

/*
 * We have to use an explicit test rule since we have to start up
 * a zebra session, and we're dependent on multiple programs.
 */
#if UseInstalledZebra
MESSAGE = $(BINDIR)/message
TIMER = $(BINDIR)/timer
ZSTOP = $(BINDIR)/zstop
DSDUMP = $(BINDIR)/dsdump
#else
MESSAGE = $(TOP)/src/msg/message
TIMER = $(TOP)/src/timer/timer
ZSTOP = $(TOP)/src/zstop/zstop
DSDUMP = $(TOP)/src/dsdump/dsdump
#endif
ZPROGS = $(MESSAGE) $(TIMER) $(ZSTOP) $(DSDUMP)
TESTPROJ = /net/shared/zebra/project/test
DSCONFIG = perm.config
DATA_DIR = $(TESTPROJ)/data
SOCKET = /tmp/DStest.socket
INVENTORY = 10
#ifdef DebugFlag
DEBUG_FLAG = -debug
TESTOUT =
#else
DEBUG_FLAG =
TESTOUT = > /dev/null 2>&1
#endif
ALINE = ./aline -n 4 $(DEBUG_FLAG) -per 3 -inv $(INVENTORY)
DSDAEMON = DSDLOADFILE=. ./dsDaemon $(DEBUG_FLAG)
APPLE = ./apple -a -c 2 $(DEBUG_FLAG)

.PHONY: test.session test.aline test.aline.only 

.PHONY: test.close test.apple test.apple.only

test:: test.session test.aline.only test.apple.only test.close

test.aline: test.aline.only test.close

test.apple: test.apple.only test.close

#define TEST_ENV \
	-@ZEBRA_SOCKET=$(SOCKET); export ZEBRA_SOCKET; \ @@\
	DSDUMP=$(DSDUMP); export DSDUMP; \ @@\
	ZEB_PROJECT=$(TESTPROJ); export ZEB_PROJECT; \ @@\
	DATA_DIR=$(DATA_DIR); export DATA_DIR; \ 


test.session $(SOCKET): $(ZPROGS) dsDaemon dsDaemon.lf $(DSCONFIG)
	TEST_ENV
	echo "Starting a zebra test session... ZEBRA_SOCKET=$$ZEBRA_SOCKET"; \
	$(ZSTOP) $(TESTOUT); $(RM) $$ZEBRA_SOCKET; \
	set -x; \
	HOST=`uname -n` $(MESSAGE) $(TESTOUT) ; \
	($(TIMER) $(TESTOUT) &); \
	($(DSDAEMON) $(DSCONFIG) $(TESTOUT) &); \
	sleep 5; /* give daemon time to connect */

test.aline.only: aline $(SOCKET)
	TEST_ENV
	echo "Assembly line testing with 'aline'..."; \
	set +x; \
	RunTest($(ALINE) -shar $(TESTOUT),"shared cdf platform, r/o"); \
	RunTest($(ALINE) -shar -w $(TESTOUT),"shared cdf platform, r/w"); \
	RunTest($(ALINE) -rem $(TESTOUT),"linked cdf (files removed)"); \
	RunTest($(ALINE) -ov $(TESTOUT),"linked cdf (files copied)"); \
	RunTest($(ALINE) -z -sh $(TESTOUT),"shared znf platform, r/o"); \
	RunTest($(ALINE) -z -sh -w $(TESTOUT),"shared znf platform, r/w"); \
	RunTest($(ALINE) -z -r $(TESTOUT),"linked znf (files removed)"); \
	RunTest($(ALINE) -z -ov $(TESTOUT),"linked znf (files copied)"); \
	echo "End assembly line testing."

test.apple.only: apple $(SOCKET) $(DSDUMP)
	TEST_ENV
	RunTest($(APPLE),"William Tell, arrows away"); \
	echo "End apple testing."

test.close:
	TEST_ENV
	echo "Ending zebra test session..."; \
	$(ZSTOP) $(TESTOUT); $(RM) $$ZEBRA_SOCKET

clean::
	$(RM) $(SOCKET)
	$(RM) test.znf		/* created by apple test program */    

/*
 * Saber stuff.  This is a bit complicated, depending on what you are
 * trying to debug.  The saber "#" construct makes it through the Sun
 * preprocessor; others may give trouble.
 *
 * Note that imake produces some saber rules for the normal program
 * targets.  Either those or these below can be used.  Or add your own!
 */
saber_lib:
	#setopt ansi
	#load $(CFLAGS) -I/usr/local/include $(DSLIBOBJS) $(DCOBJS)
	#load -Bstatic $(LIBS) $(LIBGCC)

ZebraMakeDepend()

CcDependTarget($(SRCS))
CccDependTarget($(SRCS_CXX))
CcDependTarget($(TESTSRCS))

LintTarget()

DistfilesTarget($(DISTFILES))

