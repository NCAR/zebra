/* -*- C -*-
 * Imakefile for the DataStore
 */

MFVERSION="$Id: Imakefile,v 1.37 1996-01-23 20:00:50 granger Exp $"

DEPLIBS=$(LIBZEB) /*$(LIBNETCDF)*/
/* LIBNETCDF=/net/src/netcdf-2.3.2/libsrc/libnetcdf.a */
LIBMPROF=/dt/granger/libc_mp.a
/* SYSLIBS= $(LIBMPROF) */
SYSLIBS= $(LIBREGEXP) $(LIBMATH) $(LIBTERMCAP)
LIBS=$(LIBZEB) $(LIBRDSS) $(XLIBS) $(LIBNETCDF) $(LIBHDF)
LIBGCC=/locallib/gcc-lib/sparc-sun-sunos4.1/2.4.5/libgcc.a
CLIBS=$(LIBGCC)
/*PROOF=/net/CenterLine/bin/proof*/

INCLUDES = $(HDFINCLUDES) $(NETCDFINCLUDES)

/* DEFINES = -DHDF_TEST -DHDF_INTERFACE */	/* for HDF testing */
DEBUGGER = xgdb
#ifdef DebugFlag
DEBUG = -DDEBUG -DNoBuffer -DDEBUGGER="\"$(DEBUGGER)\""
#endif
DEFINES = $(HDFDEFINES) $(DEBUG) /* -DTEST_TIME_UNITS */

#CCOPTIONS=
#CCOPTIONS=-pipe -pg
#CCOPTIONS=-pg
#LOCAL_LDFLAGS=-static
#COMPILE_CC=$(CC)
#COMPILE.c=$(COMPILE_CC) $(CFLAGS) $(CPPFLAGS) -c

/* 
 * DSOBJS, DSSRCS = Daemon-specific object modules 
 */
DSOBJS= Daemon.o d_DataTables.o d_Config.o d_Scan.o d_Debug.o
DSSRCS= Daemon.c d_DataTables.c d_Config.c d_Scan.c d_Debug.c

/* 
 * DSLIBOBJS, DSLIBSRCS = normal DS library code 
 */
DSLIBOBJS = Appl.o DFA_Appl.o DataFileAccess.o DFA_GRIB.o DFA_NetCDF.o \
	ingest.o GetList.o DFA_Boundary.o DFA_Raster.o Fields.o DFA_Zeb.o \
	DFA_Grads.o GRIB.o d_Notify.o DFA_HDF.o
DSLIBSRCS = Appl.c DFA_Appl.c DataFileAccess.c DFA_GRIB.c DFA_NetCDF.c \
	ingest.c GetList.c DFA_Boundary.c DFA_Raster.c Fields.c DFA_Zeb.c \
	DFA_Grads.c GRIB.c d_Notify.c DFA_HDF.c

/* 
 * DCOBJS, DCSRCS =  data chunk modules 
 */
DCOBJS = DataChunk.o dc_Boundary.o dc_IRGrid.o dc_Image.o \
	dc_MetData.o dc_RGrid.o dc_Scalar.o dc_Transp.o dc_Attr.o \
	dc_Location.o dc_NSpace.o
DCSRCS = DataChunk.c dc_Boundary.c dc_IRGrid.c dc_Image.c \
	dc_MetData.c dc_RGrid.c dc_Scalar.c dc_Transp.c dc_Attr.c \
	dc_Location.c dc_NSpace.c

UTILSRCS = rfdump.c zfdump.c GRIBdump.c

/*
 * For debugging
 */
TESTSRCS = dstest.c dctest.c nstest.c aline.c apple.c hdflook.c

/*
 * All of the sources in this directory, for the make depend.
 */
SRCS = $(DSLIBSRCS) $(DCSRCS) $(DSSRCS) $(UTILSRCS)

PRIVATE_HEADERS = BoundaryFile.h DataChunkP.h dslib.h znfile.h \
		  RasterFile.h commands.h dfa.h dsDaemon.h dsPrivate.h \
		  GRIB.h Appl.h

HEADERS = DataStore.h DataChunk.h ingest.h fields.h ds_fields.h

DISTFILES = Imakefile $(SRCS) $(TESTSRCS) $(PRIVATE_HEADERS) \
            $(HEADERS) Daemon.state nstest.config

DMNOBJS = $(DSOBJS) $(DSLIBOBJS) $(DCOBJS)
CompleteProgramTarget(dsDaemon, $(DMNOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

UILoadFileTarget(dsDaemon.lf,Daemon.state)

/*
 * Make the library.
 */
NormalLibraryTarget (ZebDS, $(DSLIBOBJS) $(DCOBJS))

InstallLibrary (ZebDS, $(LIBDIR))

BuildIncludes($(HEADERS),.,.)

/*
 * Dump routines.
 */
CompleteProgramTarget (rfdump, rfdump.o, /**/, /**/, /**/)

ZFOBJS = zfdump.o $(DSLIBOBJS) $(DCOBJS)
CompleteProgramTarget (zfdump, $(ZFOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

GDOBJS = GRIBdump.o GRIB.o
CompleteProgramTarget (GRIBdump, $(GDOBJS), $(LIBZEB), $(LIBZEB), $(LIBMATH))

/*
 * Test routines.
 */
#ifdef notdef
NSOBJS = nstest.o $(DSLIBOBJS) $(DCOBJS)
TestProgramTarget (nstest, $(NSOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))
#endif

#if HasHDF
TestProgramTarget (hdflook, hdflook.o, /**/, $(LIBHDF), /**/)
#endif

APOBJS = apple.o $(DSLIBOBJS) $(DCOBJS)
TestProgramTarget (apple, $(APOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

#ifdef notdef
cc_nstest:: nstest.c $(DSLIBSRCS) $(DCSRCS)
	# setopt ansi
	# load $(ALLDEFINES) nstest.c  $(DSLIBSRCS) $(DCSRCS) \
		$(DEPLIBS) $(LIBS) $(SYS_LIBRARIES)  \
		$(EXTRA_LIBRARIES)   $(CLIBS)
	# link
#endif

CflowTarget (nstest, nstest.c $(DSLIBSRCS) $(DCSRCS), /**/)

ALOBJS = aline.o $(DSLIBOBJS) $(DCOBJS)
TestProgramTarget (aline, $(ALOBJS), $(DEPLIBS), $(LIBS), $(SYSLIBS))

/*
 * We have to use an explicit test rule since we have to start up
 * a zebra session, and we're dependent on multiple programs.
 */
#if UseInstalledZebra
ZEBPROGS = $(BINDIR)/message $(BINDIR)/timer $(BINDIR)/zstop $(BINDIR)/dsdump
#else
ZEBPROGS = $(TOP)/src/msg/message $(TOP)/src/timer/timer \
	   $(TOP)/src/zstop/zstop $(TOP)/src/dsdump/dsdump
#endif
TESTPROJ = /net/shared/zebra/project/test
DATA_DIR = $(TESTPROJ)/data
SOCKET = ./test.socket
INVENTORY = 10
#ifdef DebugFlag
DEBUG_FLAG = -debug /* -blow */
TESTOUT =
#else
DEBUG_FLAG =
TESTOUT = > /dev/null 2>&1
#endif
ALINE = aline -nconsumers 4 $(DEBUG_FLAG) -period 4 -inventory $(INVENTORY)
DSDAEMON = ./dsDaemon $(DEBUG_FLAG)
APPLE = apple $(DEBUG_FLAG)

test:: test.aline.only test.apple.only test.close

test.aline: test.aline.only test.close

test.apple: test.apple.only test.close

#define TEST_ENV \
	-@ZEB_SOCKET=$(SOCKET); export ZEB_SOCKET; \ @@\
	DSDUMP=$(BINDIR)/dsdump; export DSDUMP; \ @@\
	DATA_DIR=$(DATA_DIR); export DATA_DIR; \ 

test.session $(SOCKET): $(ZEBPROGS) dsDaemon nstest.config
	TEST_ENV
	echo "Starting a zebra test session... ZEB_SOCKET=$$ZEB_SOCKET"; \
	$(BINDIR)/zstop; rm -f $$ZEB_SOCKET; \
	set -x; message /* -d */ ; (timer &); ($(DSDAEMON) nstest.config &); \
	sleep 5; /* give daemon time to connect */

#ifndef LinuxArchitecture
test.aline.only: aline $(SOCKET)
	TEST_ENV
	echo "Assembly line testing with 'aline'..."; \
	set +x; \
	echo " -- Shared netCDF platform" ; \
	if $(ALINE) -share $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi; \
	echo " -- Linked netCDF platforms (files removed)" ; \
	if $(ALINE) -remove $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi; \
	echo " -- Shared ZNF platform" ; \
	if $(ALINE) -znf -share $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi; \
	echo " -- Linked ZNF platforms (files removed)" ; \
	if $(ALINE) -znf -remove $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi
#else
test.aline.only: aline $(SOCKET)
	TEST_ENV
	echo "Assembly line testing with 'aline'..."; \
	set +x; \
	echo " -- Shared netCDF platform" ; \
	if $(ALINE) -share $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi; \
	echo " -- Linux NFS bug -- skipping linked netCDF test" ; \
	echo " -- Shared ZNF platform" ; \
	if $(ALINE) -znf -share $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi; \
	echo " -- Linux NFS bug -- skipping linked znf test"
#endif

test.apple.only: apple $(SOCKET)
	TEST_ENV
	echo "Running 'apple', arrows away..."; \
	if $(APPLE) $(TESTOUT); \
		then echo "Passed."; \
	else \
		echo "FAILED."; \
	fi

test.close: $(BINDIR)/zstop
	TEST_ENV
	echo "Ending zebra test session..."; \
	$(BINDIR)/zstop; rm -f $$ZEB_SOCKET

/*
 * Saber stuff.  This is a bit complicated, depending on what you are
 * trying to debug.  The saber "#" construct makes it through the Sun
 * preprocessor; others may give trouble.
 *
 * Note that imake produces some saber rules for the normal program
 * targets.  Either those or these below can be used.  Or add your own!
 */
saber_lib:
	#setopt ansi
	#load $(CFLAGS) -I/usr/local/include $(DSLIBSRCS) $(DCOBJS)
	#load -Bstatic $(LIBS) $(LIBGCC)

DependTarget()

LintTarget()

DistfilesTarget($(DISTFILES))
