C		Copyright (C) 1987,88,89,90,91 by UCAR
C	University Corporation for Atmospheric Research
C		   All rights reserved
C
C No part of this work covered by the copyrights herein may be reproduced
C or used in any form or by any means -- graphic, electronic, or mechanical,
C including photocopying, recording, taping, or information storage and
C retrieval systems -- without permission of the copyright owner.
C 
C This software and any accompanying written materials are provided "as is"
C without warranty of any kind.  UCAR expressly disclaims all warranties of
C any kind, either express or implied, including but not limited to the
C implied warranties of merchantibility and fitness for a particular purpose.
C UCAR does not indemnify any infringement of copyright, patent, or trademark
C through use or modification of this software.  UCAR does not provide 
C maintenance or updates for its software.
C
# include "rg_status.h"

c
c DO_RGRID Generic rectangular gridding routine
c
c ENTRY:
c	grid	The grid to be filled
c	xdim	x-dimension of the grid
c	ydim	y-dimension of the grid
c	nsta	number of raw data points
c	rawdata	array of raw data values
c	badflag	bad data flag
c	xloc	array of x locations of the raw data points
c	yloc	array of y locations of the raw data points
c	xlo	x value of the left side of the grid
c	ylo	y value of the bottom of the grid
c	xhi	x value of the right side of the grid
c	yhi	y value of the top of the grid
c	scratch	scratch array at least (xdim x ydim) in size
c EXIT:
c	RG_OK is returned and the grid has been filled with data 
c	interpolated to the grid locations
c		--OR--
c	A status other than RG_OK is returned and the grid is unchanged.
c	Possible status values are in rg_status.h
c
	integer function dorgrid (grid, xdim, ydim, npts, rawdata, 
     +		badflag, xloc, yloc, xlo, ylo, xhi, yhi, scratch)

# include "rgrid.h"

	integer	xdim, ydim, npts
	real	grid(xdim,ydim)
	real	rawdata(npts), badflag, xloc(npts), yloc(npts)
	real	xlo, ylo, xhi, yhi
	real	scratch(xdim,ydim)

	integer	i, status
	real	xin(21,MAXSTN)
	logical	dotri, del
c
c If the number of points, x-dimension, or y-dimension changed
c we need to triangulate again
c
	dotri = (npts .ne. NP) .or. (xdim .ne. NX) .or. (ydim .ne. NY)
c
c Initialize some variables in the common block
c
	NX = xdim
	NY = ydim
	NP = npts
	XMIN = xlo
	XMAX = xhi
	YMIN = ylo
	YMAX = yhi
	FLAG = badflag
	IPAR = 0
	IPAROV = 0

	do 10, i = 1, npts
c	
c	We have to triangulate again if locations changed
c
		dotri = dotri .or. (xloc(i) .ne. X(i))
		dotri = dotri .or. (yloc(i) .ne. Y(i))
c
c	Put the locations in the X and Y arrays
c
		X(i) = xloc(i)
		Y(i) = yloc(i)
c
c	Is this a good point?  We have to triangulate again if
c	the deleted status of the point changed.
c
		del = rawdata(i) .eq. badflag
		dotri = dotri .or. (del .neqv. DELETED(i))
		DELETED(i) = del
 10	continue
c
c Use linear fit
c
	NAPROX = 0
c
c Calculate spacing information and statistics
c
	call stats (status)
	if (status .ne. RG_OK) then
		dorgrid = status
		return
	endif
c
c Do the triangulation and the weighting, if necessary
c
	if (dotri) then
		call triang
		call wghts
	endif
c
c Set up for the polynomial fit if we're using it
c
	if (NAPROX .eq. 1) call compx (xin, index)
c
c Actually fill in the grid
c
	call approx (rawdata, grid, scratch, 1, xin, index)
	dorgrid = RG_OK
	return
	end




       SUBROUTINE TRIANG
C ROUTINE THAT DETERMINES THE TRIANGLES USED FOR THE INTERPOLATION.
       INTEGER IPT(3)
C IBPTS = THE NUMBER OF POINTS THAT FORM THE OUTER BOUNDARY OF THE
C TRIANGULATION.
C IBNDRY(*) CONTAINS THE POINTS THAT FORM THE BOUNDARY.  IBNDRY(I) IS
C CLOCKWISE FROM IBNDRY(I+1). IBNDRY(IBPTS) IS CLOCKWISE FROM IBNDRY(1).
C ITRS = THE NUMBER OF TRIANGLES.
C ITRNGL(*) CONTAINS INFORMATION ABOUT THE TRIANGULATION.
C ITRNGL(I,1-3) = THE THREE POINTS THAT FORM TRIANGLE I.
C THE THREE POINTS ARE ORIENTED COUNTERCLOCKWISE, I.E. ITRNGL(I,1)
C IS CLOCKWISE FROM ITRNGL(I,2), ITRNGL(I,2) IS CLOCKWISE FROM ITRNGL(I,3)
C AND ITRNLG(I,3) IS CLOCKWISE FROM ITRNGL(I,1).
C ITRNGL(I,4) = THE TRIANGLE THAT SHARES THE EDGE FORMED BY ITRNGL(I,1)
C AND ITRNGL(I,2).
C ITRNGL(I,5) = THE TRIANGLE THAT SHARES THE EDGE FORMED BY ITRNGL(I,2)
C AND ITRNGL(I,3).
C ITRNGL(I,6) = THE TRIANGLE THAT SHARES THE EDGE FORMED BY ITRNGL(I,1)
C AND ITRNGL(I,3).

# include "rgrid.h"

C
C     INITIALIZATION.
C
       ITRS=0
       IBPTS=0
       IBPTNO=0
       DO 5 I=1,3
  5    IPT(I)=0
       DO 10 I=1,MAXSTN
  10   IBNDRY(I)=0
       DO 15 J=1,6
       DO 15 I=1,MAXSTN
       ITRNGL(I,J)=0
  15   CONTINUE
C
C     TEST THE DATA.
C
C DEGENERATE CASE: ONLY THREE STATIONS.
       IF(NSTNS.EQ.3) THEN
C GET THE THREE STATIONS.
         IJK=0
         DO 35 I=1,NP
         IF(.NOT.DELETED(I)) THEN
           IJK=IJK+1
           IPT(IJK)=I
         ENDIF
  35     CONTINUE
C ORIENT THE THREE STATIONS COUNTERCLOCKWISE.
         CALL ORIENT(IPT(1),IPT(2),IPT(3),IBNDRY(1),IBNDRY(2),IBNDRY(3))
C ONE TRIANGLE AND THREE BOUNDARY POINTS.
         ITRS=1
         IBPTS=3
         DO 45 I=1,3
         ITRNGL(1,I)=IBNDRY(I)
  45     ITRNGL(1,I+3)=0
         GO TO 900
       ENDIF
C
C     FIND THE MIDPOINT OF THE RECTANGLE AND SORT THE PAM STATIONS
C     BY THERE DISTANCE FROM THE MIDPOINT.
C
       CALL DSORT
C
C     GET THE FIRST TRIANGLE.
C
       IPT(1)=IUSED(1)
       IPT(2)=IUSED(2)
       IPT(3)=IUSED(3)
C FIND THE COUNTERCLOCKWISE ORIENTATION OF THE POINTS IPT(*).
       CALL ORIENT(IPT(1),IPT(2),IPT(3),IBNDRY(1),IBNDRY(2),IBNDRY(3))
C NO. OF POINTS THAT FORM THE BOUNDARY.
       IBPTS=3
C FIRST TRIANGLE.
       ITRS=1
       ITRNGL(ITRS,1)=IBNDRY(1)
       ITRNGL(ITRS,2)=IBNDRY(2)
       ITRNGL(ITRS,3)=IBNDRY(3)
       DO 100 I=1,NSTNS-3
C GET NEXT POINT THAT IS CLOSEST TO MIDPOINT OF CLOSEST TWO POINTS.
       IPT(3)=IUSED(I+3)
C FIND BOUNDARY SEGMENT THAT IS CLOSEST TO IPT(3).
       DISTMN=1.E+30
       DO 50 J=1,IBPTS
       IPT(1)=IBNDRY(J)
       IF(J.LT.IBPTS) THEN
         IPT(2)=IBNDRY(J+1)
         IP1=J+1
       ELSE
         IPT(2)=IBNDRY(1)
         IP1=1
       ENDIF
C DON'T CONSIDER JTH BOUNDARY SEGMENT IF IT IS HIDDEN FROM IPT(3).
C VECTOR FROM IPT(1) TO IPT(2) - BOUNDARY SEGMENT.
       V1X=X(IPT(2))-X(IPT(1))
       V1Y=Y(IPT(2))-Y(IPT(1))
C VECTOR FROM IPT(1) TO IPT(3).
       V2X=X(IPT(3))-X(IPT(1))
       V2Y=Y(IPT(3))-Y(IPT(1))
C CROSS PRODUCT V2 X V1.
       V2CV1=V2X*V1Y-V2Y*V1X
       IF(V2CV1.GT.0.) THEN
C MIDPOINT OF BOUNDARY SEGMENT.
         XMID=X(IPT(1))+(X(IPT(2))-X(IPT(1)))/2.
         YMID=Y(IPT(1))+(Y(IPT(2))-Y(IPT(1)))/2.
C DISTANCE TO MIDPOINT.
         DISTSQ=(X(IPT(3))-XMID)**2+(Y(IPT(3))-YMID)**2
         IF(DISTSQ.LT.DISTMN) THEN
           DISTMN=DISTSQ
           IBPT1=IPT(1)
           IBPT2=IPT(2)
           IBPTNO=IP1
         ENDIF
       ENDIF
  50   CONTINUE
C NEW TRIANGLE.
       ITRS=ITRS+1
       ITRNGL(ITRS,1)=IBPT1
       ITRNGL(ITRS,2)=IPT(3)
       ITRNGL(ITRS,3)=IBPT2
       CALL CONT(IBPT1,IBPT2,6,ITRS)
C LAWSON'S DIAGONAL EXCHANGE ON ALL QUADRALATERALS FORMED BY ITRS AND
C NEIGHBORING TRIANGLES.
       DO 55 J=4,6
       IF(ITRNGL(ITRS,J).NE.0) THEN
         ITRSX=ITRNGL(ITRS,J)
         CALL LAWSON(ITRS,ITRSX)
       ENDIF
  55   CONTINUE
C ADD THE NEW BOUNDARY PT. BETWEEN THE POINTS CLOCKWISE AND COUNTERCLOCKWISE.
       DO 60 J=IBPTS,IBPTNO,-1
       IBNDRY(J+1)=IBNDRY(J)
  60   CONTINUE
       IBPTS=IBPTS+1
       IBNDRY(IBPTNO)=IPT(3)
C
C     SEE IF NEED TO ADD TRIANGLES CLOCKWISE FROM THE NEW BOUNDARY POINT.
C
C ADD UP TO 3 NEW TRIANGLES.
       DO 75 J=1,3
       CALL CLOCKW(IPT(3),NRMVD)
       IF(NRMVD.EQ.0) GO TO 77
  75   CONTINUE
C
C     SEE IF ADD TRIANGLES COUNTERCLOCKWISE FROM IPT(3).
C
C ADD UP TO 3 NEW TRIANGLES.
  77   DO 85 J=1,3
       CALL CCLOCK(IPT(3),NRMVD)
       IF(NRMVD.EQ.0) GO TO 100
  85   CONTINUE
  100  CONTINUE
C
C     TRY TO OPTIMIZE THE TRIANGULATION.
C
C SKIP OPTIMIZATION IF USE POLYNOMIAL CURVE-FIT AND NOT PLOTTING
C EDDY FIELD.  ONLY WANT CONVEX HULL
       IF(NAPROX.EQ.1.AND.IPAR.NE.61.AND.IPAROV.NE.61) GO TO 900
C LAWSON'S DIAGONAL EXCHANGE ON EVERY PAIR OF ADJACENT TRIANGLES.
       DO 110 I=1,ITRS-1
       DO 110 J=I+1,ITRS
C SEE IF TRIANGLE I IS ADJACENT TO TRIANGLE J.
       INDEX=0
       DO 105 K=4,6
       IF(ITRNGL(I,K).EQ.J) INDEX=1
  105  CONTINUE
C LAWSON'S DIAGONAL EXCHANGE IF ADJACENT.
       IF(INDEX.EQ.1) CALL LAWSON(I,J)
  110  CONTINUE
C
C CHECK FOR SMALL TRIANGLES AND DO LAWSON'S DIAGONAL EXCHANGE ON ANY FOUND.
       DO 150 I=1,ITRS
       IPT(1)=ITRNGL(I,1)
       IPT(2)=ITRNGL(I,2)
       IPT(3)=ITRNGL(I,3)
C VECTOR FROM IP2 TO IP1.
       V1X=X(IPT(1))-X(IPT(2))
       V1Y=Y(IPT(1))-Y(IPT(2))
C VECTOR FROM IP2 TO IP3.
       V2X=X(IPT(3))-X(IPT(2))
       V2Y=Y(IPT(3))-Y(IPT(2))
C CROSS PRODUCT .5*(V2 X V1) = .5*V1*V2*SIN(ANGLE BETWEEN) =
C (AREA OF TRIANGLE I).
       V2CV1=.5*ABS(V2X*V1Y-V2Y*V1X)
       V1=SQRT(V1X**2+V1Y**2)
       V2=SQRT(V2X**2+V2Y**2)
C V1*V2*.25 = .5*(AREA OF TRIANGLE FORMED BY POINTS OF TRIANGLE I
C IF V1 AND V2 ARE ORTHOGONAL).  IF AREA OF TRIANGLE I IS TOO SMALL,
C TRY LAWSON'S DIAGONAL EXCHANGE.
       IF(V2CV1.LE.(V1*V2*.25)) THEN
         DO 120 J=4,6
         IF(ITRNGL(I,J).NE.0) THEN
           ITRSX=ITRNGL(I,J)
           CALL LAWSON(I,ITRSX)
         ENDIF
  120    CONTINUE
       ENDIF
  150  CONTINUE
C
  900  RETURN
       END




       SUBROUTINE DSORT
C ROUTINE TO FIND THE MIDPOINT OF THE RECTANGLE CONTAINING THE PAM
C STATIONS AND SORTING THE STATIONS BY DISTANCE FROM THE MIDPOINT.
C IUSED(1) = STATION NEAREST MIDPOINT.
C IUSED(NSTNS) = STATION FURTHEST FROM MIDPOINT.

# include "rgrid.h"

       REAL DIST(MAXSTN)
C
C     INITIALIZATION
C
       DO 10 I=1,MAXSTN
       IUSED(I)=0
  10   DIST(I)=0.
C
C GET PAM STATION NEAREST TO RECTANGLE MIDPOINT.
       DISTNC=1.E+30
       XMIDPT=(XMAX+XMIN)/2.
       YMIDPT=(YMAX+YMIN)/2.
       DO 20 I=1,NP
       IF(.NOT.DELETED(I)) THEN
         DSTSQ=(X(I)-XMIDPT)**2+(Y(I)-YMIDPT)**2
         IF(DSTSQ.LT.DISTNC) THEN
           DISTNC=DSTSQ
           IUSED(1)=I
         ENDIF
       ENDIF
  20   CONTINUE
C
C ONE STATION IN SORTED LIST.
       IX=1
C GET DISTANCE FROM IUSED(1) FOR OTHER STATIONS AND SORT IN ASCENDING
C ORDER OF DISTANCE FROM IUSED(1).
       DO 100 I=1,NP
       IF(I.NE.IUSED(1) .AND. .NOT.DELETED(I)) THEN
         DISTNC=(X(I)-X(IUSED(1)))**2+(Y(I)-Y(IUSED(1)))**2
         DO 90 J=1,IX
         IF(DISTNC.LT.DIST(J)) THEN
           DO 80 K=IX,J,-1
           IUSED(K+1)=IUSED(K)
           DIST(K+1)=DIST(K)
  80       CONTINUE
           IX=IX+1
           IUSED(J)=I
           DIST(J)=DISTNC
           GO TO 100
         ENDIF
  90     CONTINUE
         IX=IX+1
         IUSED(IX)=I
         DIST(IX)=DISTNC
       ENDIF
  100  CONTINUE
C
       RETURN
       END




       SUBROUTINE CONT(IPNT1,IPNT2,ILOCAT,ITRIAN)
C ROUTINE TO FIND THE TRIANGLES THAT SHARE THE EDGE FORMED BY POINTS
C IPNT1 AND IPNT2 OF TRIANGLE ITRIAN.

# include "rgrid.h"

C
       NGHBRS=0
       DO 100 I=1,ITRS
       IF(I.NE.ITRIAN) THEN
C SEE IF IPNT1 IS PART OF TRIANGLE I.
         DO 10 J=1,3
         IF(ITRNGL(I,J).EQ.IPNT1) GO TO 20
  10     CONTINUE
C IPNT1 NOT IN I.  GO TO NEXT TRIANGLE.
         GO TO 100
C IPNT1 IS PART OF I.  SEE IF IPNT2 IS ALSO PART OF I.
  20     ILOC1=J
         DO 30 J=1,3
         IF(ITRNGL(I,J).EQ.IPNT2) GO TO 40
  30     CONTINUE
C IPNT2 IS NOT PART OF I.  GO TO NEXT TRIANGLE.
         GO TO 100
C IPNT1 AND IPNT2 ARE BOTH IN I.  ADD ITRIAN TO THE LIST OF NEIGHBOR
C TRIANGLES OF I.
  40     ILOC2=J
         NGHBRS=NGHBRS+1
         MAXLOC=MAX(ILOC1,ILOC2)
         MINLOC=MIN(ILOC1,ILOC2)
         IF(MAXLOC.EQ.2.AND.MINLOC.EQ.1) THEN
           ITRNGL(I,4)=ITRIAN
           GO TO 60
         ENDIF
         IF(MAXLOC.EQ.3.AND.MINLOC.EQ.2) THEN
           ITRNGL(I,5)=ITRIAN
           GO TO 60
         ENDIF
         IF(MAXLOC.EQ.3.AND.MINLOC.EQ.1) THEN
           ITRNGL(I,6)=ITRIAN
           GO TO 60
         ENDIF
C ADD TRIANGLE I TO THE LIST OF NEIGHBOR TRIANGLES OF ITRIAN.
  60     ITRNGL(ITRIAN,ILOCAT)=I
C QUIT IF HAVE FOUND THE TWO NEIGHBORS OF ITRIAN.
  80     IF(NGHBRS.EQ.2) RETURN
       ENDIF
 100   CONTINUE
       RETURN
       END




       SUBROUTINE LAWSON(NTR1,NTR2)
C ROUTINE THAT IMPLEMENTS LAWSON'S DIAGONAL EXCHANGE ON THE QUADRILATERAL
C FORMED BY NEIGHBORING TRIANGLES NTR1 AND NTR2.
C REFERENCE: "SOFTWARE FOR C1 SURFACE INTERPOLATION," C.L. LAWSON IN
C MATHEMATICAL SOFTWARE III, ED. JOHN RICE, 1977.
       DIMENSION IPT(4),MPT(3)
C IPT(1) AND IPT(2) ARE THE POINTS SHARED BY NTR1 AND NTR2.  IPT(3) IS
C THE UNSHARED POINT OF NTR1.  IPT(4) IS THE UNSHARED POINT OF NTR2.

# include "rgrid.h"

C
C SKIP IF USE POLYNOMIAL CURVE-FIT AND NOT PLOTTING EDDY FIELD.
C ONLY INTERESTED IN CONVEX HULL.  NO NEED TO OPTIMIZE TRIANGULATION.
       IF(NAPROX.EQ.1.AND.IPAR.NE.61.AND.IPAROV.NE.61) RETURN
C FIND THE SHARED POINTS.
       NSHARD=0
       DO 10 I=1,3
       DO 10 J=1,3
       IF(ITRNGL(NTR1,I).EQ.ITRNGL(NTR2,J)) THEN
         NSHARD=NSHARD+1
         IPT(NSHARD)=ITRNGL(NTR1,I)
         IF(NSHARD.EQ.2) GO TO 20
       ENDIF
  10   CONTINUE
C FIND POINTS NOT SHARED.
  20   DO 30 I=1,3
C TRIANGLE NTR1.
       IF(ITRNGL(NTR1,I).NE.IPT(1).AND.ITRNGL(NTR1,I).NE.IPT(2))
     *IPT(3)=ITRNGL(NTR1,I)
C TRIANGLE NTR2.
       IF(ITRNGL(NTR2,I).NE.IPT(1).AND.ITRNGL(NTR2,I).NE.IPT(2))
     *IPT(4)=ITRNGL(NTR2,I)
  30   CONTINUE
C ORIENT THE THREE POINTS FROM TRIANGLE NTR1 COUNTERCLOCKWISE.
       CALL ORIENT(IPT(1),IPT(2),IPT(3),MPT(1),MPT(2),MPT(3))
C SHUFFLE THE POINTS MPT(1-3) AND COPY THEM INTO IPT(*) SO THAT
C IPT(1) AND IPT(2) ARE THE POINTS SHARED BY NTR1 AND NTR2 AND IPT(3)
C IS THE POINT OF NTR1 THAT IS NOT SHARED.  IPT(1-3) WILL THEN BE THE
C POINTS OF NTR1 ORIENTED COUNTERCLOCKWISE.
       DO 35 I=1,3
C FIND THE POINT OF NTR1 NOT SHARED.
       IF(MPT(I).EQ.IPT(3)) NOTSHR=I
  35   CONTINUE
       IF(NOTSHR.EQ.1) THEN
         IPT(1)=MPT(2)
         IPT(2)=MPT(3)
         IPT(3)=MPT(1)
       ENDIF
       IF(NOTSHR.EQ.2) THEN
         IPT(1)=MPT(3)
         IPT(2)=MPT(1)
         IPT(3)=MPT(2)
       ENDIF
       IF(NOTSHR.EQ.3) THEN
         IPT(1)=MPT(1)
         IPT(2)=MPT(2)
         IPT(3)=MPT(3)
       ENDIF
C TEST TO SEE IF QUADRALATERAL IS CONVEX.
       V1X=X(IPT(3))-X(IPT(1))
       V1Y=Y(IPT(3))-Y(IPT(1))
       V2X=X(IPT(1))-X(IPT(4))
       V2Y=Y(IPT(1))-Y(IPT(4))
C CROSS PRODUCT V1 X V2.
       V1CV2=V1X*V2Y-V2X*V1Y
C OTHER SIDE OF QUADRALATERAL.
       W1X=X(IPT(3))-X(IPT(2))
       W1Y=Y(IPT(3))-Y(IPT(2))
       W2X=X(IPT(2))-X(IPT(4))
       W2Y=Y(IPT(2))-Y(IPT(4))
C CROSS PRODUCT W1 X W2.
       W1CW2=W1X*W2Y-W1Y*W2X
C IF QUADRALATERAL IS CONVEX, CROSS PRODUCTS WILL HAVE OPPOSITE SIGNS.
C QUIT IF THEY DON'T.
       IF(V1CV2*W1CW2.GE.0.) RETURN
C QUADRALATERAL IS CONVEX.  GET THE CURRENT DIAGONAL U1.
       U1X=X(IPT(1))-X(IPT(2))
       U1Y=Y(IPT(1))-Y(IPT(2))
C ABSOLUTE VALUES OF ALL VECTORS.
       U1=SQRT(U1X**2+U1Y**2)
       V1=SQRT(V1X**2+V1Y**2)
       V2=SQRT(V2X**2+V2Y**2)
       W1=SQRT(W1X**2+W1Y**2)
       W2=SQRT(W2X**2+W2Y**2)
C THE ABSOLUTE VALUES OF THE SINES OF THE INTERNAL ANGLES OF NTR1.
       SNU1W2=ABS((U1X*W2Y-W2X*U1Y)/(U1*W2))
       SNU1V2=ABS((U1Y*V2X-U1X*V2Y)/(U1*V2))
C THE MINIMUM INTERNAL ANGLE.
       RMNTR1=MIN(SNU1W2,SNU1V2)
C THE ABSOLUTE VALUES OF THE SINES OF THE INTERNAL ANGLES OF NTR2.
       SNU1W1=ABS((W1X*U1Y-W1Y*U1X)/(U1*W1))
       SNV1U1=ABS((U1Y*V1X-U1X*V1Y)/(U1*V1))
C MINIMUM OF INTERIOR ANGLES.
       RMNTR2=MIN(SNU1W1,SNV1U1)
C MAXIMUM OF THE MINIMUM INTERIOR ANGLES FOR THE CURRENT DIAGONALIZATION.
       RMNCUR=MIN(RMNTR1,RMNTR2)
C TEST ALTERNATE DIAGONALIZATION.
C U2 IS ALTERNATE DIAGONAL.
       U2X=X(IPT(4))-X(IPT(3))
       U2Y=Y(IPT(4))-Y(IPT(3))
       U2=SQRT(U2X**2+U2Y**2)
C ABSOLUTE VALUES OF THE SINES OF THE INTERNAL ANGLES OF THE FIRST TRIANGLE.
       SNU2W1=ABS((U2Y*W1X-U2X*W1Y)/(U2*W1))
       SNU2W2=ABS((U2Y*W2X-U2X*W2Y)/(U2*W2))
C ABSOLUTE VALUES OF THE SINES OF THE INTERNAL ANGLES OF THE SECOND TRIANGLE.
       SNU2V1=ABS((U2Y*V1X-U2X*V1Y)/(U2*V1))
       SNU2V2=ABS((U2X*V2Y-U2Y*V2X)/(U2*V2))
C MINIMUM INTERNAL ANGLES IN EACH TRIANGLE.
       RMNTRA=MIN(SNU2W1,SNU2W2)
       RMNTRB=MIN(SNU2V1,SNU2V2)
C MAXIMUM OF THE MINIMUM INTERNAL ANGLES.
       RMNALT=MIN(RMNTRA,RMNTRB)
C QUIT IF CURRENT DIAGONALIZATION HAS GREATEST MAX. MIN. INTERNAL ANGLE.
       IF(RMNCUR.GE.RMNALT) RETURN
C ALTERNATE DIAGONALIZATION IS PREFERRED.
C ELIMINATE TRIANGLES NTR1 AND NTR2 FROM TRIANGLE LIST.
       DO 60 I=1,6
       ITRNGL(NTR1,I)=0
  60   ITRNGL(NTR2,I)=0
C ELIMINATE NTR1 AND NTR2 AS NEIGHBORING TRIANGLES.
       DO 80 I=1,ITRS
       IF(I.NE.NTR1.AND.I.NE.NTR2) THEN
         DO 70 J=4,6
         IF(ITRNGL(I,J).EQ.NTR1.OR.ITRNGL(I,J).EQ.NTR2) ITRNGL(I,J)=0
  70     CONTINUE
       ENDIF
  80   CONTINUE
C ADD TWO NEW TRIANGLES.  BOTH ORIENTED COUNTERCLOCKWISE.
       ITRNGL(NTR1,1)=IPT(4)
       ITRNGL(NTR1,2)=IPT(2)
       ITRNGL(NTR1,3)=IPT(3)
       ITRNGL(NTR2,1)=IPT(3)
       ITRNGL(NTR2,2)=IPT(1)
       ITRNGL(NTR2,3)=IPT(4)
C NTR1 AND NTR2 ARE NEIGHBORS.
       ITRNGL(NTR1,6)=NTR2
       ITRNGL(NTR2,6)=NTR1
C SET TABLE FOR OTHER NEIGHBORS.
       CALL CONT(IPT(3),IPT(2),5,NTR1)
       CALL CONT(IPT(2),IPT(4),4,NTR1)
       CALL CONT(IPT(3),IPT(1),4,NTR2)
       CALL CONT(IPT(1),IPT(4),5,NTR2)
       RETURN
       END




       SUBROUTINE CLOCKW(NTR,NRMVD)
C ROUTINE TO CHECK THE THREE BOUNDARY POINTS - NTR AND THE TWO POINTS
C CLOCKWISE FROM NTR - TO SEE IF THEY ARE CONCAVE AND TO ADD THE TRIANGLE
C FORMED BY THEM TO THE TRIANGULATION IF THEY ARE CONCAVE.
       INTEGER IPT(2)

# include "rgrid.h"

C
C     SEE IF NEED TO ADD A TRIANGLE CLOCKWISE FROM THE NEW BOUNDARY POINT.
C
C SANGLE IS THE SINE OF AN ANGLE.  IF THE SINE OF THE ANGLE BETWEEN TWO BOUNDARY
C POINTS IS GREATER THAN SANGLE, THEN A TRIANGLE IS ADDED TO THE TRIANGULATION.
C SINE OF AN ANGLE OF APPROX. 20 DEGREES.
       SANGLE=.3
       NRMVD=0
C GET THE TWO POINTS THAT ARE CLOCKWISE FROM NTR.
       IF(IBPTNO.GT.2) THEN
         IP1=IBPTNO-1
         IP2=IBPTNO-2
       ELSE
         IF(IBPTNO.EQ.2) THEN
           IP1=1
           IP2=IBPTS
         ELSE
           IP1=IBPTS
           IP2=IBPTS-1
         ENDIF
       ENDIF
       IPT(1)=IBNDRY(IP1)
       IPT(2)=IBNDRY(IP2)
C GET THE BOUNDARY SEGMENT VECTORS IPT(1) TO IPT(2) AND IPT(1) TO NTR.
       V1X=X(IPT(2))-X(IPT(1))
       V1Y=Y(IPT(2))-Y(IPT(1))
       V2X=X(NTR)-X(IPT(1))
       V2Y=Y(NTR)-Y(IPT(1))
C LENGTHS OF THE VECTORS.
       V1=SQRT(V1X**2+V1Y**2)
       V2=SQRT(V2X**2+V2Y**2)
C CROSS PRODUCT V1 X V2.
       V1CV2=V1X*V2Y-V1Y*V2X
C SINE OF ANGLE BETWEEN THEM.
       VSIN=V1CV2/(V1*V2)
C TEST TO SEE IF ADD NEW TRIANGLE.
       IF(V1CV2.GT.1.E-4.AND.VSIN.GT.SANGLE) THEN
C YES. ADD TRIANGLE FORMED BY IPT(1),IPT(2) AND NTR.
         NRMVD=1
         ITRS=ITRS+1
C TRIANGLE ORIENTED COUNTERCLOCKWISE.
         ITRNGL(ITRS,1)=NTR
         ITRNGL(ITRS,2)=IPT(1)
         ITRNGL(ITRS,3)=IPT(2)
         CALL CONT(IPT(1),IPT(2),5,ITRS)
         CALL CONT(IPT(1),NTR,4,ITRS)
C LAWSON'S DIAGONAL EXCHANGE.
         DO 75 J=4,6
         IF(ITRNGL(ITRS,J).NE.0) THEN
           ITRSX=ITRNGL(ITRS,J)
           CALL LAWSON(ITRS,ITRSX)
         ENDIF
  75     CONTINUE
C REMOVE IPT(1) FROM LIST OF BOUNDARY POINTS.
         IF(IP1.LT.IBPTS) THEN
           DO 70 J=IP1,IBPTS-1
           IBNDRY(J)=IBNDRY(J+1)
  70       CONTINUE
         ENDIF
         IBPTS=IBPTS-1
C ADJUST LOCATION OF POINT NTR IN THE LIST OF BOUNDARY POINTS.
         IF(IBPTNO.GT.1) IBPTNO=IBPTNO-1
       ENDIF
       RETURN
       END




       SUBROUTINE CCLOCK(NTR,NRMVD)
C ROUTINE TO CHECK THE THREE POINTS - NTR AND THE TWO POINTS THAT
C ARE COUNTERCLOCKWISE FROM NTR - TO SEE IF THEY ARE CONCAVE AND TO
C ADD THE TRIANGLE FORMED BY THEM TO THE TRIANGULATION IF THEY ARE CONCAVE.
       INTEGER IPT(2)

# include "rgrid.h"

C
C SINE OF AN ANGLE. SEE COMMENTS IN SUBROUTINE CLOCK.
       SANGLE=.3
C
C     SEE IF ADD A TRIANGLE COUNTERCLOCKWISE FROM IPT(3).
C
       NRMVD=0
C GET TWO BOUNDARY SEGMENTS COUNTERCLOCKWISE FROM NTR.
       IF(IBPTNO.LT.(IBPTS-1)) THEN
         IP1=IBPTNO+1
         IP2=IBPTNO+2
       ELSE
         IF(IBPTNO.EQ.(IBPTS-1)) THEN
           IP1=IBPTS
           IP2=1
         ELSE
           IP1=1
           IP2=2
         ENDIF
       ENDIF
       IPT(1)=IBNDRY(IP1)
       IPT(2)=IBNDRY(IP2)
C GET VECTORS IPT(1) TO NTR AND IPT(1) TO IPT(2).
       V1X=X(NTR)-X(IPT(1))
       V1Y=Y(NTR)-Y(IPT(1))
       V2X=X(IPT(2))-X(IPT(1))
       V2Y=Y(IPT(2))-Y(IPT(1))
C LENGTHS OF VECTORS.
       V1=SQRT(V1X**2+V1Y**2)
       V2=SQRT(V2X**2+V2Y**2)
C CROSS PRODUCT V1 X V2.
       V1CV2=V1X*V2Y-V1Y*V2X
C SINE OF ANGLE BETWEEN THEM.
       VSIN=V1CV2/(V1*V2)
C TEST TO SEE IF ADD NEW TRIANGLE.
       IF(V1CV2.GT.1.E-4.AND.VSIN.GT.SANGLE) THEN
C YES. ADD TRIANGLE FORMED BY NTR,IPT(1) AND IPT(2).
         NRMVD=1
         ITRS=ITRS+1
C TRIANGLE ORIENTED COUNTERCLOCKWISE.
         ITRNGL(ITRS,1)=NTR
         ITRNGL(ITRS,2)=IPT(2)
         ITRNGL(ITRS,3)=IPT(1)
         CALL CONT(IPT(1),IPT(2),5,ITRS)
         CALL CONT(IPT(1),NTR,6,ITRS)
C LAWSON'S DIAGONAL EXCHANGE.
         DO 85 J=4,6
         IF(ITRNGL(ITRS,J).NE.0) THEN
           ITRSX=ITRNGL(ITRS,J)
           CALL LAWSON(ITRS,ITRSX)
         ENDIF
  85     CONTINUE
C REMOVE POINT IPT(1) FROM THE LIST OF BOUNDARY POINTS.
         IF(IP1.LT.IBPTS) THEN
           DO 90 J=IP1,IBPTS-1
           IBNDRY(J)=IBNDRY(J+1)
  90       CONTINUE
         ENDIF
         IF(IBPTNO.EQ.IBPTS) IBPTNO=IBPTNO-1
         IBPTS=IBPTS-1
       ENDIF
       RETURN
       END




       SUBROUTINE ORIENT(NPT1,NPT2,NPT3,MPT1,MPT2,MPT3)
C ROUTINE TO DETERMINE THE COUNTERCLOCKWISE ORIENTATION OF THE THREE
C POINTS NPT1, NPT2 AND NPT3.  MPT1, MPT2 AND MPT3 ARE THE RETURNED
C POINTS IN COUNTERCLOCKWISE ORIENTATION.  MPT1 IS COUNTERCLOCKWISE
C FROM MPT3, MPT2 IS COUNTERCLOCKWISE FROM MPT1, AND MPT3 IS
C COUNTERCLOCKWISE FROM MPT2.
       INTEGER NPT(3)

# include "rgrid.h"

C
       NPT(1)=NPT1
       NPT(2)=NPT2
       NPT(3)=NPT3
C GET THE POINT THAT HAS THE SMALLEST X VALUE.
       XMN=1.E+30
       DO 30 I=1,3
       IF(X(NPT(I)).LT.XMN) THEN
         XMN=X(NPT(I))
         MINX=NPT(I)
       ENDIF
  30   CONTINUE
C OF THE REMAINING POINTS, GET THE ONE WITH THE GREATEST X VALUE.
       XMX=-1.E+30
       DO 40 I=1,3
       IF(NPT(I).NE.MINX.AND.X(NPT(I)).GT.XMX) THEN
         XMX=X(NPT(I))
         MAXX=NPT(I)
       ENDIF
  40   CONTINUE
C GET THE REMAINING POINT.
       DO 45 I=1,3
       IF(NPT(I).NE.MAXX.AND.NPT(I).NE.MINX) LAST=NPT(I)
  45   CONTINUE
C VECTOR FROM MINX TO MAXX.
       V1X=X(MAXX)-X(MINX)
       V1Y=Y(MAXX)-Y(MINX)
C VECTOR FROM MINX TO LAST.
       V2X=X(LAST)-X(MINX)
       V2Y=Y(LAST)-Y(MINX)
C CROSS PRODUCT V2 X V1.
       V2CV1=V2X*V1Y-V2Y*V1X
C TEST TO SEE IF LAST IS ABOVE OR BELOW LINE FORMED BY MINX AND MAXX.
       IF(V2CV1.LT.0..OR.(ABS(X(LAST)-X(MINX)).LE.1.E-6.AND.
     *Y(LAST).GE.Y(MINX))) THEN
C ABOVE.
         MPT2=MAXX
         MPT3=LAST
       ELSE
C BELOW.
         MPT2=LAST
         MPT3=MAXX
       ENDIF
       MPT1=MINX
       RETURN
       END




       SUBROUTINE PTSRCH(XX,YY,NTRIN,NCONTN,NTROUT)
C ROUTINE TO SEARCH FOR THE TRIANGLE THAT CONTAINS POINT (XX,YY).
C NTRIN IS AN ESTIMATE OF THE TRIANGLE THAT CONTAINS (XX,YY) AND IS
C USED AS A STARTING TRIANGLE FOR THE SEARCH.  NTROUT IS THE LAST
C TRIANGLE SEARCHED.
C NCONTN IS THE SAME VARIABLE
C USED IN SUBROUTINE CNTAIN.  NCONTN IS 0 IF (XX,YY) IS WITHIN THE AREA
C COVERED BY STATIONS AND IS NONZERO OTHERWISE.
C ITRNDX(I) = 0 IF TRIANGLE I HAS NOT BEEN SEARCHED YET.
C ITRNDX(I) = 1 IF TRIANGLE I HAS BEEN SEARCHED.

# include "rgrid.h"

       INTEGER ITRNDX(MAXSTN)
C
       NTROUT=NTRIN
       DO 10 I=1,MAXSTN
  10   ITRNDX(I)=0
       DO 100 I=1,ITRS
       CALL CNTAIN(XX,YY,NTROUT,NCONTN)
C QUIT IF (XX,YY) IS IN TRIANGLE NTROUT.
       IF(NCONTN.EQ.0) RETURN
C OTHERWISE MARK TRIANGLE NTROUT AS HAVING BEEN SEARCHED AND GET
C A TRIANGLE CONTIGUOUS WITH IT AS THE NEXT TRIANGLE TO BE TRIED.
       ITRNDX(NTROUT)=1
       NTROUT=ITRNGL(NTROUT,NCONTN)
C QUIT THIS SECTION OF ROUTINE IF THERE IS NO CONTIGUOUS TRIANGLE
C ON THE NCONTN SIDE OF TRIANGLE NTROUT.
       IF(NTROUT.EQ.0) GO TO 110
  100  CONTINUE
C
C SEARCH THROUGH ALL TRIANGLES THAT HAVE NOT BEEN TRIED YET.
  110  DO 200 I=1,ITRS
       IF(ITRNDX(I).EQ.0) THEN
         CALL CNTAIN(XX,YY,I,NCONTN)
         IF(NCONTN.EQ.0) THEN
           NTROUT=I
           RETURN
         ENDIF
       ENDIF
  200  CONTINUE
       RETURN
       END




       SUBROUTINE CNTAIN(XX,YY,NTR,NCONTN)
C ROUTINE TO DETERMINE IF POINT (XX,YY) IS CONTAINED IN TRIANGLE NTR.
C IF (XX,YY) IS IN TRIANGLE NTR, NCONTN = 0.  OTHERWISE, NCONTN IS
C THE EDGE OF THE TRIANGLE THAT (XX,YY) IS BEYOND.
C THE EDGE NUMBERS (4,5 OR 6) CORRESPOND TO THE ENTRIES IN ARRAY
C ITRNGL(*) FOR THE CONTIGUOUS EDGES OF EACH TRIANGLE.
       REAL EDGE(3,2)
       INTEGER IPT(3)

# include "rgrid.h"

C
       NCONTN=0
C THREE POINTS OF TRIANGLE NTR.
       IPT(1)=ITRNGL(NTR,1)
       IPT(2)=ITRNGL(NTR,2)
       IPT(3)=ITRNGL(NTR,3)
C EDGE 1. IPT(1) TO IPT(2).
       EDGE(1,1)=X(IPT(2))-X(IPT(1))
       EDGE(1,2)=Y(IPT(2))-Y(IPT(1))
C EDGE 2. IPT(2) TO IPT(3).
       EDGE(2,1)=X(IPT(3))-X(IPT(2))
       EDGE(2,2)=Y(IPT(3))-Y(IPT(2))
C EDGE 3. IPT(3) TO IPT(1).
       EDGE(3,1)=X(IPT(1))-X(IPT(3))
       EDGE(3,2)=Y(IPT(1))-Y(IPT(3))
C
       DO 10 I=1,3
C VECTOR FROM ORIGIN PT. OF EDGE I TO (XX,YY).
       V1X=XX-X(IPT(I))
       V1Y=YY-Y(IPT(I))
C CROSS PRODUCT V1 X EDGE I.
       V1CEI=V1X*EDGE(I,2)-V1Y*EDGE(I,1)
C CROSS PRODUCT MUST BE ZERO OR NEGATIVE FOR (XX,YY) TO BE IN TRIANGLE NTR.
       IF(V1CEI.GT.0.) THEN
C NOT IN TRIANGLE.  QUIT.
         NCONTN=3+I
         RETURN
       ENDIF
 10    CONTINUE
       RETURN
       END




       SUBROUTINE LINWT(NTR,PAM,W1,W2,W3)
C CALCULATE THE INTERPOLATION WEIGHTS(W1,W2,W3) FOR TRIANGLE NTR
C USING A LINEAR INTERPOLATION.

# include "rgrid.h"

       REAL PAM(MAXSTN)
C
       W1=0.
       W2=0.
       W3=0.
       IP1=ITRNGL(NTR,1)
       IP2=ITRNGL(NTR,2)
       IP3=ITRNGL(NTR,3)
C
C SOLVE THE FOLLOWING EQUATION
C FOR THE THREE PAM STATIONS TO GET THE WEIGHTS:
C PAM(I) = W1 + W2*X(I) + W3*Y(I)
C
       W3=PAM(IP1)*(X(IP3)-X(IP2))+PAM(IP2)*(X(IP1)-X(IP3))
     *+PAM(IP3)*(X(IP2)-X(IP1))
       W3=W3/(Y(IP1)*(X(IP3)-X(IP2))+Y(IP2)*(X(IP1)-X(IP3))+
     *Y(IP3)*(X(IP2)-X(IP1)))
       W2=PAM(IP2)-PAM(IP1)+W3*(Y(IP1)-Y(IP2))
       W2=W2/(X(IP2)-X(IP1))
       W1=PAM(IP1)-W3*Y(IP1)
       W1=W1-X(IP1)*(PAM(IP2)-PAM(IP1)+W3*(Y(IP1)-Y(IP2)))/
     *(X(IP2)-X(IP1))
       RETURN
       END




       SUBROUTINE GENWT(PAM)
C CALCULATE THE INTERPOLATION WEIGHTS FOR ALL TRIANGLES USING A LINEAR
C INTERPOLATION.

# include "rgrid.h"

       REAL PAM(MAXSTN)
C
       DO 10 I=1,ITRS
       CALL LINWT(I,PAM,WEIGHT(I,1),WEIGHT(I,2),WEIGHT(I,3))
       WEIGHT(I,4)=0.
       WEIGHT(I,5)=0.
       WEIGHT(I,6)=0.
  10   CONTINUE
       RETURN
       END




       SUBROUTINE WGHTS
C ROUTINE TO FIND THE TRIANGLE CONTAINING EACH GRID POINT.
C JW(I,J) - THE TRIANGLE CONTAINING IGRID POINT I,J.
C JW(I,J) = -1 IF GRID POINT I,J IS NOT IN THE AREA COVERED BY PAM
C STATIONS.
C SEE THE CODE FOR THE CALCULATION OF THE X AND Y VALUES OF GRID POINT I,J.

# include "rgrid.h"

C
C     INITIALIZATION
C
       DO 20 K=1,MAXDIM
       DO 20 J=1,MAXDIM
  20   JW(J,K)=0
C
C ESTIMATE OF THE TRIANGLE THAT CONTAINS THE GRID POINT CURRENTLY CONSIDERED.
       NTRIN=1
C GENERATE THE GRID POINTS, FIND WHICH TRIANGLE EACH IS IN, AND
C STORE THE INTERPOLATION WEIGHTS FOR EACH POINT.
       DO 50 J=1,NY
       XX=X0
       YY=Y0+(J-1)*DY
       DO 40 I=1,NX
       CALL PTSRCH(XX,YY,NTRIN,NCONTN,NTROUT)
C SEE IF (XX,YY) IS WITHIN TRIANGULATED AREA.
       IF(NCONTN.GT.0) THEN
C NO.
         JW(I,J)=-1
       ELSE
C YES.
         JW(I,J)=NTROUT
         NTRIN=NTROUT
       ENDIF
       XX=XX+DX
  40   CONTINUE
  50   CONTINUE
       RETURN
       END




       SUBROUTINE STAREA
C FIND THE AREA OF INFLUENCE OF EACH STATION LOCATION.
C AREA(I) = AREA OF INFLUENCE OF STATION I.

# include "rgrid.h"

C
       DO 10 I=1,MAXSTN
  10   AREA(I)=0.
C
       DO 100 I=1,ITRS
       X1=X(ITRNGL(I,1))
       X2=X(ITRNGL(I,2))
       X3=X(ITRNGL(I,3))
       Y1=Y(ITRNGL(I,1))
       Y2=Y(ITRNGL(I,2))
       Y3=Y(ITRNGL(I,3))
C
       XM1=(X2+X3)/2.
       XM2=(X1+X3)/2.
       XM3=(X1+X2)/2.
       YM1=(Y2+Y3)/2.
       YM2=(Y1+Y3)/2.
       YM3=(Y1+Y2)/2.
C
       XB=(X1+X2+X3)/3.
       YB=(Y1+Y2+Y3)/3.
C
       AREA(ITRNGL(I,1))=AREA(ITRNGL(I,1))+FAREA(X1,Y1,XM3,YM3,XB,YB)+
     *FAREA(X1,Y1,XM2,YM2,XB,YB)
       AREA(ITRNGL(I,2))=AREA(ITRNGL(I,2))+FAREA(X2,Y2,XM1,YM1,XB,YB)+
     *FAREA(X2,Y2,XM3,YM3,XB,YB)
       AREA(ITRNGL(I,3))=AREA(ITRNGL(I,3))+FAREA(X3,Y3,XM1,YM1,XB,YB)+
     *FAREA(X3,Y3,XM2,YM2,XB,YB)
 100   CONTINUE
       RETURN
       END




       FUNCTION FAREA(X1,Y1,X2,Y2,X3,Y3)
C ROUTINE TO FIND THE AREA OF THE TRIANGLE FORMED BY THE THREE POINTS
C (X1,Y1),(X2,Y2) AND (X3,Y3).
C
       FAREA=ABS((X1-X3)*(Y2-Y3)-(X2-X3)*(Y1-Y3))/2.
       RETURN
       END




       SUBROUTINE STATS(STATUS)
C ROUTINE TO TEST THE STATION LOCATIONS TO SEE THAT THERE IS ENOUGH
C SPREAD TO DO A REASONABLE TRIANGULATION.
C STATION LOCATION STATISTICS THAT ARE USED FOR PLOTTING ARE ALSO
C CALCULATED.
C
C STATUS is RG_OK if the points are spread out enough, 
C otherwise STATUS reflects some problem in point spacing.
C See rgrid.h for other status values.
C 

# include "rgrid.h"

       INTEGER STATUS
C
       STATUS=RG_OK
C
C     STATISTICS.
C
       XMEAN=0.
       YMEAN=XMEAN
       XY=XMEAN
       XSQRD=XMEAN
       NSTNS=0
       DO 10 I=1,NP
       IF(.NOT.DELETED(I)) THEN
         XMEAN=XMEAN+X(I)
         YMEAN=YMEAN+Y(I)
         XY=XY+X(I)*Y(I)
         XSQRD=XSQRD+X(I)*X(I)
         NSTNS=NSTNS+1
       ENDIF
  10   CONTINUE
C QUIT IF NOT ENOUGH STATIONS.
       IF(NSTNS.LT.3) THEN
         STATUS=RG_NOTENUFPTS
         RETURN
       ENDIF
C X DISTANCE BETWEEN GRID POINTS.
       DX=(XMAX-XMIN)/(NX+1)
C Y DISTANCE BETWEEN GRID POINTS.
       DY=(YMAX-YMIN)/(NY+1)
C REFERENCE POINT.
       X0=XMIN+DX
       Y0=YMIN+DY
C
C     CALCULATE THE LINE OF REGRESSION.
C
C QUIT AT THIS POINT IF USE POLYNOMIAL REGRESSION.
       IF(NAPROX.EQ.1) RETURN
C CALCULATE THE RESIDUALS FROM THE LINE OF REGRESSION.
       XMEAN=XMEAN/REAL(NSTNS)
       YMEAN=YMEAN/REAL(NSTNS)
       DENOM=XSQRD-NSTNS*XMEAN*XMEAN
       IF(ABS(DENOM).GT.1.E-6) THEN
         SLOPE=(XY-NSTNS*XMEAN*YMEAN)/DENOM
       ELSE
         SLOPE=1.E+6
       ENDIF
       RES=0.
       DO 20 I=1,NP
       IF(.NOT.DELETED(I)) THEN
         Y1=YMEAN+SLOPE*(X(I)-XMEAN)
         RES=RES+ABS(Y1-Y(I))
       ENDIF
  20   CONTINUE
C MEAN OF RESIDUALS.
       RES=RES/REAL(NSTNS)
       RTEST=SQRT((XMAX-XMIN)**2+(YMAX-YMIN)**2)
C IF RMS OF RESIDUALS IS WITHIN 3 % OF RTEST, STATIONS ARE NOT FAR
C ENOUGH APART TO TRIANGULATE.
       IF(RES.LE.(.03*RTEST)) STATUS=RG_COLLINEAR
       RETURN
       END



# ifdef notdef
       SUBROUTINE GENXY
C ROUTINE TO COMPUTE THE X AND Y LOCATIONS OF PAM STATIONS FROM THE
C LATITUDE AND LONGITUDE.

# include "rgrid.h"

C
C GET THE REFERENCE LATITUDE AND LONGITUDE.
       CALL rorigin(REFLAT,REFLON)
       DO 20 I=1,NP
C CONVERT LONGITUDE FROM DEGREES TO RADIANS.
       Y(I)=RLAT(I)*.01745329301
C X AND Y IN KM.
C RADIUS OF EARTH = 6372.0 KM.
C (PI/180)*(RADIUS OF EARTH IN KM) = 111.212379
       X(I)=-1.*(RLON(I)-REFLON)*COS(Y(I))*111.212379
       Y(I)=(RLAT(I)-REFLAT)*111.212379
  20   CONTINUE
       RETURN
       END




       SUBROUTINE SETUP(INDEX)
C ROUTINE TO EXCLUDE STATIONS THAT HAVE BAD DATA OR OUT OF RANGE DATA,
C CHECK FOR A VALID LOW PASS FILTER STEP SIZE, GENERATE X AND Y VALUES
C FOR EACH STATION FROM LAT AND LON VALUES AND COMPUTE STATISTICS
C OF THE DISTRIBUTED STATIONS INCLUDING X0,Y0,DX AND DY.
C INDEX IS RETURNED.  INDEX = 0 IF THE STATIONS ARE SUFFICIENTLY
C DISTRIBUTED FOR A TRIANGULATION.  INDEX = 1 IF THEY ARE LOCATED
C ON A LINE.

# include "rgrid.h"

       CHARACTER*7 FLD
C
C     INITIALIZE EXCLUDED STATION INDICATOR.
C
       DO 10 I=1,NP
  10   DELETED(I)=.FALSE.
C
C     TEST THE DATA FOR BAD VALUES.  EXCLUDE STATIONS THAT HAVE BAD DATA.
C
C NON-WIND DATA.
       IF(IPAR.NE.56.AND.IPAR.NE.57.AND.IPAR.NE.60.AND.IPAR.NE.61
     *.AND.IPAR.NE.77.AND.IPAR.NE.78.AND.IPAR.NE.88.AND.IPAR.NE.143
     *.AND.IPAR.NE.999) THEN
         DO 50 I=1,NP
         IF(ABS(Z(I)-FLAG).LE.1.E-6) THEN
C BAD DATA.  EXCLUDE ITH STATION.
           DELETED(I)=.TRUE.
           CALL rgstname(NUSRNO(I))
           WRITE(LUOUT,30) FSTRNG,NAME
  30       FORMAT(' * THE ',A7,' DATA OF STATION ',
     *A10,' IS BAD. STATION IS EXCLUDED. *')
         ELSE
C TEST DATA TO SEE IF WITHIN LIMITS.
           IF(Z(I).LT.RLOLIM(IPAR).OR.Z(I).GT.RUPLIM(IPAR)) THEN
C NOT WITHIN LIMITS.  EXCLUDE STATION.
             DELETED(I)=.TRUE.
             CALL rgstname(NUSRNO(I))
             WRITE(LUOUT,40) FSTRNG,Z(I),NAME
  40         FORMAT(' * ',A7,' (',G7.1,') OF STATION ',A10,
     *' IS OUTSIDE LIMITS. STATION EXCLUDED. *')
           ENDIF
         ENDIF
  50     CONTINUE
       ENDIF
C
C     SCALAR OVERLAY FIELD.
C
       IPOV=ABS(IPAROV)
       IF(IPAROV.NE.0.AND.IPOV.NE.56.AND.IPOV.NE.57.AND.IPOV.NE.58.
     *AND.IPOV.NE.60.AND.IPOV.NE.61.AND.IPOV.NE.77.AND.IPOV.NE.78
     *.AND.IPOV.NE.88.AND.IPOV.NE.143.AND.IPOV.NE.999) THEN
         DO 200 I=1,NP
         IF(.NOT.DELETED(I)) THEN
           IF(ABS(OVRPAM(I)-FLAG).LE.1.E-6) THEN
C BAD DATA.  EXCLUDE ITH STATION.
             DELETED(I)=.TRUE.
             CALL rgstname(NUSRNO(I))
             WRITE(LUOUT,30) OVFLD,NAME
           ELSE
C TEST DATA TO SEE IF WITHIN LIMITS.
             IF(OVRPAM(I).LT.RLOLIM(ABS(IPAROV)).OR.OVRPAM(I).GT.
     *RUPLIM(ABS(IPAROV))) THEN
C NOT WITHIN LIMITS.  EXCLUDE STATION.
               DELETED(I)=.TRUE.
               CALL rgstname(NUSRNO(I))
               WRITE(LUOUT,40) OVFLD,OVRPAM(I),NAME
             ENDIF
           ENDIF
         ENDIF
  200    CONTINUE
       ENDIF
C
C WIND DATA.
       IF((IPAR.GT.55.AND.IPAR.LT.59).OR.IPAR.EQ.60.OR.IPAR.EQ.61
     *.OR.IPAR.EQ.77.OR.IPAR.EQ.78.OR.IPAR.EQ.88.OR.IPAR.EQ.143
     *.OR.IPAR.EQ.999.OR.IPAROV.NE.0) THEN
         DO 100 I=1,2
         DO 100 J=1,NP
         IF(.NOT.DELETED(J)) THEN
           IF(I.EQ.1) THEN
C EAST WIND SPEED.
             DATVAL=U(J)
             FLD='u_wind'
C FIELD NUMBER INDEX FOR EAST WIND IS 15.
             RLO=RLOLIM(15)
             RUP=RUPLIM(15)
           ELSE
C NORTH WIND SPEED.
             DATVAL=V(J)
             FLD='v_wind'
C FIELD NUMBER INDEX FOR NORTH WIND IS 16.
             RLO=RLOLIM(16)
             RUP=RUPLIM(16)
           ENDIF
           IF(ABS(DATVAL-FLAG).LE.1.E-6) THEN
             DELETED(J)=.TRUE.
             CALL rgstname(NUSRNO(J))
             WRITE(LUOUT,30) FLD,NAME
           ELSE
             IF(DATVAL.LT.RLO.OR.DATVAL.GT.RUP) THEN
               DELETED(J)=.TRUE.
               CALL rgstname(NUSRNO(J))
               WRITE(LUOUT,40) FLD,DATVAL,NAME
             ENDIF
           ENDIF
         ENDIF
  100    CONTINUE
       ENDIF
C CHECK THE FILTER STEP SIZE.
       IF(NFLTR.EQ.1.AND.NAPROX.EQ.0) THEN
         MINGRD=MIN(NX,NY)
         MAXSTP=0
         DO 150 I=1,10
         IF(MINGRD.GE.5*2**(I-1)) THEN
           MAXSTP=I
         ELSE
           GO TO 160
         ENDIF
  150    CONTINUE
  160    IF(MAXSTP.EQ.0) THEN
           NFLTR=0
           WRITE(LUOUT,170)
  170      FORMAT(' ** GRID NOT LARGE ENOUGH TO USE FILTER.  DATA WILL',
     *' NOT BE FILTERED. **')
         ELSE
           IF(NSTEP.GT.MAXSTP) THEN
             NSTEP=MAXSTP
             WRITE(LUOUT,180) NSTEP
  180        FORMAT(' ** FILTER STEP SIZE SET TO MAXIMUM ALLOWED - ',
     *I4,' **')
           ENDIF
         ENDIF
       ENDIF
C
C COMPUTE X AND Y VALUES FROM LATITUDE AND LONGITUDE.
       CALL GENXY
C TEST THE STATION LOCATIONS TO SEE IF CAN GET A REASONABLE TRIANGULATION.
       CALL STATS(INDEX)
C OUTPUT A BLANK LINE.
       WRITE(LUOUT,190)
  190  FORMAT(1H )
       RETURN
       END




       SUBROUTINE RECTGR(UU,VV,ZZ,OVRGRD,SCR1,SCR2)
C ROUTINE THAT COMPUTES A TRIANGULATION OF THE AREA COVERED BY
C PAM STATIONS, INTERPOLATION WEIGHTS AND THE INTERPOLATED VALUES
C OF THE PARAMETER SELECTED ON A RECTANGULAR GRID.

# include "rgrid.h"

       LOGICAL NDX(MAXSTN)
       REAL UU(NX,NY),VV(NX,NY),ZZ(NX,NY),OVRGRD(NX,NY)
       REAL SCR1(NX,NY),SCR2(NX,NY)
C
C     INITIALIZATION.
C
       NSTNSX=NSTNS
       DO 10 I=1,NP
       NDX(I)=DELETED(I)
  10   CONTINUE
C SAVE DX AND DY.  THESE ARE USED FOR AN INDIRECT WAY OF CHECKING
C TO SEE IF THE NUMBER OF GRID POINTS, NX AND NY, HAS BEEN CHANGED
C BY THE OPERATOR.  IF EITHER NX OR NY HAS BEEN CHANGED, A NEW
C SET OF INTERPOLATION WEIGHTS MUST BE COMPUTED.  IF NX IS CHANGED,
C DX CHANGES.  IF NY IS CHANGED, DY CHANGES.
       DXX=DX
       DYY=DY
C
C     SET UP DATA.
C
       CALL SETUP(INDEX)
C QUIT IF NOT ENOUGH STATIONS OR STATIONS ARE ON A LINE.
C USE ZZ(1,1) AS AN ERROR INDICATOR.
       IF(INDEX.EQ.1) THEN
         ZZ(1,1)=1.E+30
         RETURN
       ENDIF
C
C SEE IF STATIONS SAME AS PREVIOUS RUN AND IF HAVE TRIANGULATION.
       INDEX=0
       IF(NSTNSX.NE.NSTNS.OR.ITRS.EQ.0) THEN
C NO.  NOT SAME NUMBER OF STATIONS.
         INDEX=1
       ELSE
C SAME NUMBER OF STATIONS.  CHECK TO SEE IF THEY ARE THE SAME STATIONS.
         DO 300 I=1,NP
C CHECK USER NUMBERS AGAINST USER NUMBERS FROM LAST RGRID RUN
C AND CHECK TO SEE THAT THE UNEXCLUDED STATIONS ARE THE SAME AS
C THE LAST RUN.
         IF(NDX(I).NE.DELETED(I).OR.IUSED(I).NE.NUSRNO(I)) THEN
C STATION I IS NOT SAME.
           INDEX=1
           GO TO 310
         ENDIF
  300    CONTINUE
       ENDIF
C DO TRIANGULATION AND FIND INTERPOLATION WEIGHTS IF NECESSARY.
  310  IF(INDEX.EQ.1) THEN
C MUST DO IT IF NEW SET OF MESONET STATIONS OR HAVE NOT DONE IT BEFORE.
         CALL TRIANG
         CALL WGHTS
       ELSE
C MUST FIND NEW INTERPOLATION WEIGHTS IF SIZE OF GRID HAS CHANGED.
         IF(ABS(DXX-DX).GT.1.E-6.OR.ABS(DYY-DY).GT.1.E-6) CALL WGHTS
       ENDIF
C INTERPOLATE ON THE RECTANGULAR GRID.
       CALL RGRID1(UU,VV,ZZ,OVRGRD,SCR1,SCR2)
       RETURN
       END
# endif




       SUBROUTINE RGRID1(UU,VV,ZZ,OVRGRD,SCR1,SCR2)
C ROUTINE TO COMPUTE AND INTERPOLATE THE FIELD CHOSEN BY THE OPERATOR.
C VARIABLE IPAR INDICATES THE TYPE OF FIELD.
C THESE FIELDS ARE IN THE ROBOT FIELD TABLE.  THE ROBOT FIELD NUMBER INDEX:
C IPAR < 56 OR IPAR > 61 - STANDARD ROBOT FIELDS
C IPAR = 56 - DIVERGENCE(1/1.E-6*SEC)
C IPAR = 57 - VORTICITY(1/1.E-6*SEC)
C IPAR = 58 - ENERGY FLUX CONVERGENCE(DEG/1.E-3*SEC)
C IPAR = 59 - ALTITUDE(METERS)
C IPAR = 60 - WIND FIELD(METERS/SEC)
C IPAR = 61 - EDDY FIELD(METERS/SEC)
C IPAR = 77 - STRETCHING DEFORMATON(1/1.E-6*SEC)
C IPAR = 78 - SHEARING DEFORMATION(1/1.E-6*SEC)
C IPAR = 88 - TOTAL DEFORMATION(1/1.E-6*SEC)
C IPAR = 143 - VORTICITY STRETCHING (1/SEC^2 * 1.E-6) (added 4/17/89 cb)
C IPAR = 999 - AXIS OF DILATATION(DEGREES)
C

# include "rgrid.h"

       REAL SCR1(NX,NY),SCR2(NX,NY)
       REAL XIN(21,MAXSTN),UU(NX,NY),VV(NX,NY),ZZ(NX,NY),OVRGRD(NX,NY)
C
C
C     INITIALIZATION.
C
      DO 5 J=1,NY
      DO 5 I=1,NX
      ZZ(I,J)=0.
      UU(I,J)=0.
      VV(I,J)=0.
      OVRGRD(I,J)=0.
  5   CONTINUE
      IF(NAPROX.EQ.1) CALL COMPX(XIN,INDEX)
C
C     WIND FIELD AND EDDY FIELD VECTOR PLOTS.
C
       IF(IPAR.EQ.60.OR.IPAR.EQ.61) THEN
         IF(IPAR.EQ.61) CALL EDDY
         CALL APPROX(U,UU,SCR1,1,XIN,INDEX)
         CALL APPROX(V,VV,SCR1,1,XIN,INDEX)
C PLOT DATA.
       ENDIF
C
C     BASIC FIELDS AND ALTITUDE CONTOUR PLOTS.
C
       IF(IPAR.NE.56.AND.IPAR.NE.57.AND.IPAR.NE.58.AND.IPAR.NE.60
     *.AND.IPAR.NE.61.AND.IPAR.NE.77.AND.IPAR.NE.78.AND.IPAR.NE.88
     *.AND.IPAR.NE.143.AND.IPAR.NE.999) THEN
C BASIC FIELDS AND ALTITUDE.
C INTERPOLATE.
        CALL APPROX(Z,ZZ,SCR1,1,XIN,INDEX)
C INTERPOLATE WIND OR EDDY FIELD DATA IF OVERLAID ON CONTOUR PLOTS.
        IF(IPAROV.NE.0) THEN
          IF(ABS(IPAROV).EQ.61) CALL EDDY
          IF(IPAROV.EQ.60.OR.IPAROV.EQ.61) THEN
            CALL APPROX(U,UU,SCR1,1,XIN,INDEX)
            CALL APPROX(V,VV,SCR1,1,XIN,INDEX)
          ENDIF
        ENDIF
C PLOT DATA.
      ENDIF
C
C     SCALAR OVERLAY FIELD.
C
       IF(IPAROV.GT.0.AND.IPAROV.NE.56.AND.IPAROV.NE.57.AND.
     *IPAROV.NE.58.AND.IPAROV.NE.60.AND.IPAROV.NE.61.AND.
     *IPAROV.NE.77.AND.IPAROV.NE.78.AND.IPAROV.NE.88.AND.
     *IPAROV.NE.143.AND.IPAROV.NE.999) THEN
         IF(IPAROV.EQ.IPAR) THEN
C OVERLAY FIELD SAME AS CONTOUR FIELD.
           DO 60 J=1,NY
           DO 60 I=1,NX
  60       OVRGRD(I,J)=ZZ(I,J)
         ELSE
C OVERLAY FIELD DIFFERENT FROM CONTOURED FIELD.
           CALL APPROX(OVRPAM,OVRGRD,SCR1,1,XIN,INDEX)
         ENDIF
       ENDIF
C
C     DIVERGENCE, VORTICITY, ENERGY FLUX CONVERGENCE, STRETCHING
C     DEFORMATION, SHEARING DEFORMATION, TOTAL DEFORMATION, AND
C     VORTICITY STRETCHING CONTOUR PLOTS.
C
       IF(IPAR.EQ.56.OR.IPAR.EQ.57.OR.IPAR.EQ.58
     *.OR.IPAR.EQ.77.OR.IPAR.EQ.78.OR.IPAR.EQ.88
     *.OR.IPAR.EQ.143.OR.IPAR.EQ.999) THEN
       IF(NAPROX.EQ.0) THEN
         CALL LINTRP(UU,VV,ZZ,SCR1,SCR2)
       ELSE
         CALL CFITD(XIN,INDEX,0,UU,VV,ZZ,SCR1,SCR2)
       ENDIF
C
C SET DATA TO FLAG AT ALL GRID PTS. WHERE THERE IS NO DATA.
C AND MULTIPLY EVERYTHING ELSE BY 1000 SO THAT THE UNITS ARE
C 1/1.E-6*SEC FOR DIVERGENCE, VORTICITY, SHEARING DEFORMATION,
C STRETCHING DEFORMATION, AND TOTAL DEFORMATION.
C MULTIPLY BY 1000 TO GET VORTICITY STRETCHING IN UNITS OF 1/S^2 x 1E-9
C
         DO 40 J=1,NY
         DO 40 I=1,NX
         IF(JW(I,J).LT.0) THEN
           ZZ(I,J)=FLAG
         ELSEIF (IPAR.EQ.143) THEN
           ZZ(I,J) = 1000. * ZZ(I,J)
         ELSE
           IF(IPAR.NE.58.AND.IPAR.NE.999) ZZ(I,J)=1000.*ZZ(I,J)
         ENDIF
  40     CONTINUE
C DO THE SAME FOR WIND OR EDDY FIELD DATA IF IT IS TO BE OVERLAYED ON
C THE CONTOUR PLOT.
         IF(IPAROV.NE.0) THEN
           IF(ABS(IPAROV).EQ.61) THEN
             CALL EDDY
             IF(IPAROV.GT.0) THEN
               CALL APPROX(U,UU,SCR1,1,XIN,INDEX)
               CALL APPROX(V,VV,SCR1,1,XIN,INDEX)
             ENDIF
           ENDIF
           IF(IPAROV.EQ.60) THEN
             DO 70 J=1,NY
             DO 70 I=1,NX
             IF(JW(I,J).LT.0) THEN
               UU(I,J)=FLAG
               VV(I,J)=FLAG
             ENDIF
  70         CONTINUE
           ENDIF
C OVERLAY FIELD IS DIVERGENCE, VORTICITY OR EFC.
           IF(IPAROV.EQ.IPAR) THEN
             DO 80 J=1,NY
             DO 80 I=1,NX
 80          OVRGRD(I,J)=ZZ(I,J)
           ENDIF
         ENDIF
C PLOT DIVERGENCE, VORTICITY OR ENERGY FLUX CONVERGENCE.
       ENDIF
C
       RETURN
       END




       SUBROUTINE LINTRP(UU,VV,ZZ,SCR1,SCR2)
C CALCULATION OF DIVERGENCE, VORTICITY AND ENERGY FLUX DENSITY
C USING LINEAR INTERPOLATION.

# include "rgrid.h"

       REAL UU(NX,NY),VV(NX,NY),ZZ(NX,NY)
       REAL SCR1(NX,NY),SCR2(NX,NY)
       DATA PI/3.1415927/
C
C DIVERGENCE, VORTICITY AND ENERGY FLUX DENSITY.  INTERPOLATE WIND DATA.
         CALL APPROX(U,UU,SCR1,0,XIN,INDEX)
         CALL APPROX(V,VV,SCR1,0,XIN,INDEX)
C
C DIVERGENCE.
         IF(IPAR.EQ.56) CALL DVRG(UU,VV,ZZ)
C
         IF(IPAR.EQ.57) THEN
C VORTICITY.
           DO 50 J=1,NY
           DO 50 I=1,NX
           SCR1(I,J)=-1.*UU(I,J)
  50       CONTINUE
           CALL DVRG(VV,SCR1,ZZ)
         ENDIF
C
         IF(IPAR.EQ.58) THEN
C ENERGY FLUX DENSITY.
           CALL APPROX(Z,ZZ,SCR1,0,XIN,INDEX)
           DO 60 J=1,NY
           DO 60 I=1,NX
           SCR1(I,J)=UU(I,J)*ZZ(I,J)
           SCR2(I,J)=VV(I,J)*ZZ(I,J)
  60       CONTINUE
           CALL DVRG(SCR1,SCR2,ZZ)
         ENDIF
C
       IF(IPAR.EQ.77) THEN
C STRETCHING DEFORMATION.
         DO 70 J=1,NY
         DO 70 I=1,NX
  70     SCR2(I,J)=-1.*VV(I,J)
         CALL DVRG(UU,SCR2,ZZ)
       ENDIF
C
C SHEARING DEFORMATION.
       IF(IPAR.EQ.78) CALL DVRG(VV,UU,ZZ)
C
C TOTAL DEFORMATION.
       IF(IPAR.EQ.88) THEN
         DO 100 J=1,NY
         DO 100 I=1,NX
         SCR2(I,J)=-1.*VV(I,J)
  100    CONTINUE
C STRETCHING DEFORMATION
         CALL DVRG(UU,SCR2,ZZ)
C SQUARE IT AND SAVE RESULT.
         DO 80 J=1,NY
         DO 80 I=1,NX
         SCR1(I,J)=ZZ(I,J)*ZZ(I,J)
  80     ZZ(I,J)=0.
C SHEARING DEFORMATION
         CALL DVRG(VV,UU,ZZ)
C TOTAL DEFORMATION
         DO 90 J=1,NY
         DO 90 I=1,NX
  90     ZZ(I,J)=SQRT(SCR1(I,J)+ZZ(I,J)*ZZ(I,J))
       ENDIF
C
       IF(IPAR.EQ.999) THEN
C AXIS OF DILATATION
         DO 110 J=1,NY
         DO 110 I=1,NX
 110     SCR2(I,J)=-1.*VV(I,J)
C STRETCHING DEFORMATION IN SCR1()
         CALL DVRG(UU,SCR2,SCR1)
C SHEARING DEFORMATION IN SCR2().
         CALL DVRG(VV,UU,SCR2)
         DO 120 J=1,NY
         DO 120 I=1,NX
C AXIS OF DILATATION IN RADIANS.
         IF(SCR2(I,J).GT.0.) THEN
           IF(SCR2(I,J).LT.1.E-10) THEN
             ZZ(I,J)=PI/4.
           ELSE
             ZZ(I,J)=PI/4.-ATAN(SCR1(I,J)/SCR2(I,J))
           ENDIF
         ELSE
           IF(SCR2(I,J).GT.(-1.E-10)) THEN
             ZZ(I,J)=3.*PI/4.
           ELSE
             ZZ(I,J)=3.*PI/4.-ATAN(SCR1(I,J)/SCR2(I,J))
           ENDIF
         ENDIF
C AXIS OF DILATATION IN DEGREES.
         ZZ(I,J)=ZZ(I,J)*180./PI
  120    CONTINUE
       ENDIF

c
c vorticity stretching (added 4/17/89 cb)
c
	if (ipar .eq. 143) then
c
c	Put the divergence into the first scratch array
c
		call dvrg (uu, vv, scr1)
c
c	Put the u wind into the second scratch array with reversed signs
c
		do 130, j = 1, ny
			do 140, i = 1, nx
				scr2(i,j) = -1 * uu(i,j)
 140			continue
 130		continue
c
c	Calculate the vorticity and put it in array zz
c
		call dvrg (vv, scr2, zz)
c
c	Calculate the vorticity-divergence product (vorticity stretching)
c
		do 150, j = 1, ny
			do 160, i = 1, nx
				zz(i,j) = -scr1(i,j) * zz(i,j)
 160			continue
 150		continue
	endif
C
       RETURN
       END




       SUBROUTINE EDDY
C ROUTINE TO GET THE MEAN WIND AND SUBTRACT IT FROM THE MEASURED WIND
C SPEED FOR CALCULATING THE WIND EDDY FIELD.

# include "rgrid.h"

C
C GET AREA OF INFLUENCE OF EACH PAM STATION.
         CALL STAREA
C EAST WIND.  POSITIVE - WIND FROM THE WEST.  NEGATIVE - WIND FROM THE EAST.
         UMEAN=AVRG1(U)
C NORTH WIND.  POSITIVE - WIND FROM THE SOUTH.  NEGATIVE - WIND FROM THE NORTH.
         VMEAN=AVRG1(V)
C SUBTRACT MEAN WIND FROM WIND SPEED AT EACH PAM STATION.
         DO 10 I=1,NP
         IF(.NOT.DELETED(I)) THEN
           U(I)=U(I)-UMEAN
           V(I)=V(I)-VMEAN
         ENDIF
  10     CONTINUE
         RETURN
         END




       REAL FUNCTION AVRG1(ARRAY)
C

# include "rgrid.h"

       REAL ARRAY(MAXSTN)

	SUMA = 0.0
	SUM = 0.0
	DO 100 I = 1, NP
                IF(.NOT.DELETED(I).AND.ABS(ARRAY(I)-FLAG).GT.1.E-6) THEN
			SUMA = SUMA + AREA(I)
			SUM = SUM + ARRAY(I) * AREA(I)
		ENDIF
  100	CONTINUE

	AVRG1 = FLAG
        IF(ABS(SUMA).GT.1.E-6) AVRG1=SUM/SUMA

	RETURN
	END




       SUBROUTINE INTRP(GRID,SCR1,MODE)
C	SCALER INTERPOLATION AND FILTER ROUTINE
C

# include "rgrid.h"

       REAL GRID(NX,NY),SCR1(NX,NY)
C
C	INTERPOLATION


	DO 100 J = 1, NY
                XX=X0
                YY=Y0+(J-1)*DY
		DO 100 I = 1, NX
		  IF (JW(I, J) .GE. 0) THEN
                         NTR=JW(I,J)
                        IF(NAPROX.EQ.0) THEN
C LINEAR INTERPOLATION
                        GRID(I,J)=WEIGHT(NTR,1)+
     *XX*WEIGHT(NTR,2)+YY*WEIGHT(NTR,3)
                        ELSE
C QUADRATIC INTERPOLATION
                          X1=9.*(XX-XMIN)/(XMAX-XMIN)+1.
                          Y1=9.*(YY-YMIN)/(YMAX-YMIN)+1.
                          GRID(I,J)=WEIGHT(NTR,1)+X1*WEIGHT(NTR,2)+
     *Y1*WEIGHT(NTR,3)+X1*Y1*WEIGHT(NTR,4)+X1*X1*WEIGHT(NTR,5)+
     *Y1*Y1*WEIGHT(NTR,6)
                        ENDIF
               ENDIF
             XX=XX+DX
  100	CONTINUE

C	EXTRAPOLATE

        IF((IPAR.EQ.56.OR.IPAR.EQ.57.OR.IPAR.EQ.58.OR.
     *IPAR.EQ.77.OR.IPAR.EQ.78).OR.NFLTR.EQ.1)
     *CALL EXTRP(GRID)

C	FILTER AND FLAG

        IF(NFLTR.EQ.1) CALL LFLTR(SCR1,GRID)

	IF (MODE .NE. 0) THEN
		DO 200 J = 1, NY
			DO 200 I = 1, NX
			IF (JW(I, J) .LT. 0) GRID(I, J) = FLAG
  200		CONTINUE
	ENDIF

	RETURN
	END

C------------------------------------------------------------------------------




       SUBROUTINE EXTRP(ARRAY)
C
C	WES WILSON		APRIL, 1980

C	THIS IS A SIMPLE EXTRAPOLATION ROUTINE WHICH DAMPS THE DERIVATIVES
C	OF THE EXTRAPOLATED DATA.


	INTEGER		MIDX, MIDY, MX, MY
	INTEGER		IX, IXM1, IY, IYM1
	INTEGER		JX, JY, JXP1, JYP1, JXH, JXL, JYH, JYL, K
C

# include "rgrid.h"

       REAL ARRAY(NX,NY)
C

	MIDX = NX / 2
	MIDY = NY / 2
       IF(JW(MIDX,MIDY).LT.0) THEN
         WRITE(LUOUT,10)
  10     FORMAT(' *** WARNING: MIDPOINT OF GRID IS NOT WITHIN A',
     *' TRIANGLE. ***'/'  FILTER AND DERIVATIVE CALCULATIONS MAY BE',
     *' INCORRECT.')
       ENDIF

C	POSITIVE X-AXIS FROM THE MIDPOINT

	JXH = NX
	DO 250 IX = MIDX, NX
		JX = IX
		IF (JW(JX, MIDY) .LT. 0) GO TO 260
  250	CONTINUE
	GO TO 280
  260		CONTINUE
		JXH = JX - 1
		Z1 = ARRAY(JXH, MIDY)
		DO 270 K = JX, NX
			ARRAY(K, MIDY) = Z1
  270		CONTINUE
  280	CONTINUE

C	NEGATIVE X-AXIS FROM THE MIDPOINT

	JXL = 1
	JX = MIDX + 1
	DO 290 IX = 1, MIDX
		JX = JX - 1
		IF (JW(JX, MIDY) .LT. 0) GO TO 300
  290	CONTINUE
	GO TO 320
  300		CONTINUE
		JXL = JX + 1
		Z1 = ARRAY(JXL, MIDY)
		DO 310 K = 1, JX
			ARRAY(K, MIDY) = Z1
  310		CONTINUE
  320	CONTINUE

C	POSITIVE Y-AXIS FROM THE MIDPOINT

	JYH = NY
	DO 330 IY = MIDY, NY
		JY = IY
		IF (JW(MIDX, JY) .LT. 0) GO TO 340
  330	CONTINUE
	GO TO 360
  340		CONTINUE
		JYH = JY - 1
		Z1 = ARRAY(MIDX, JYH)
		DO 350 K = JY, NY
			ARRAY(MIDX, K) = Z1
  350		CONTINUE
  360	CONTINUE

C	NEGATIVE Y-AXIS FROM THE MIDPOINT

	JYL = 1
	JY = MIDY + 1
	DO 370 IY = 1, MIDY
		JY = JY - 1
		IF (JW(MIDX, JY) .LT. 0) GO TO 380
  370	CONTINUE
	GO TO 400
  380		CONTINUE
		JYL = JY + 1
		Z1 = ARRAY(MIDX, JYL)
		DO 390 K = 1, JY
			ARRAY(MIDX, K) = Z1
  390		CONTINUE
  400	CONTINUE

C	FIRST QUADRANT

	MX = MIDX + 1
	MY = MIDY + 1
	DO 410 IY = MY, NY
		DO 410 IX = MX, NX
			IF (JW(IX, IY) .GT. 0) GO TO 410
				IXM1 = IX - 1
				IYM1 = IY - 1
				ARRAY(IX, IY) = 
     .				   (ARRAY(IXM1,IY)+ARRAY(IX,IYM1)) / 2.
  410	CONTINUE

C	SECOND QUADRANT

	MX = MIDX - 1
	DO 420 IY = MY, NY
		JX = MIDX
		DO 420 IX = 1, MX
			JX = JX - 1
			IF (JW(JX, IY) .GT. 0) GO TO 420
				JXP1 = JX + 1
				IYM1 = IY - 1
				ARRAY(JX, IY) = 
     .				   (ARRAY(JXP1,IY)+ARRAY(JX,IYM1)) / 2.
  420	CONTINUE

C	THIRD QUADRANT

	MY = MIDY - 1
	JY = MIDY
	DO 430 IY = 1, MY
		JY = JY - 1
		JX = MIDX
		DO 430 IX = 1, MX
			JX = JX - 1
			IF (JW(JX, JY) .GT. 0) GO TO 430
				JXP1 = JX + 1
				JYP1 = JY + 1
				ARRAY(JX, JY) = 
     .				   (ARRAY(JXP1,JY)+ARRAY(JX,JYP1)) / 2.
  430	CONTINUE

C	FOURTH QUADRANT

	MX = MIDX + 1
	JY = MIDY
	DO 440 IY = 1, MY
		JY = JY - 1
		DO 440 IX = MX, NX
			IF (JW(IX, JY) .GT. 0) GO TO 440
				IXM1 = IX - 1
				JYP1 = JY + 1
				ARRAY(IX, JY) = 
     .				   (ARRAY(IXM1,JY)+ARRAY(IX,JYP1)) / 2.
  440	CONTINUE

	RETURN
	END




       SUBROUTINE LFLTR(ARRAY1,ARRAY2)

C               JIM LEISE 8/80

C   ***********************************************************

C   THIS IS A LINEAR LOW-PASS FILTER WHICH NEEDS NO EXTRA
C   ARRAY SPACE. THUS, THE FILTERED ANSWER IS RETURNED IN THE SAME
C   ARRAY ARRAY2(NX,NY,N3) THAT THE DATA IS INPUT. THE CENTRAL FILTER
C   IS A LINEAR 5-PT FILTER AND THE BOUNDARY FILTER IS COMPUTED
C   USING A MIRROR EXTENSION. THUS, THE TOTAL FILTER IS LINEAR.

C         ********** NSTEP CONTROL FOR 1-DIM **********

C        STEP RESTRICTION:  5*2**(NSTEP-1) .LE. MAX(NX,NY,N3)
C         PASSBAND .LE. 2**(NSTEP+2)  POINTS/CYCLE
C          STOPBAND .GE. 2**(NSTEP)  POINTS/CYCLE.

C         ************ MULTIDIMENSIONAL USE ************

C   PARAMETER CONTROL FOR THE THREE DIMENSIONS CAN BE REALIZED
C   VIA COMON/FLTRPL/ WHERE NS CORRESPONDS TO NSTEP. IF THIS
C   COMON IS NOT USED, THE VALUES OF NS ARE DEFAULTED TO NSTEP
C   -I.E. NSTEP IS USED IN PLACE OF ANY ZEROS.

C   ***********************************************************

C THE DIMENSION OF ARRAY2 HAS BEEN CHANGED FROM (NX, NY) TO (1)
C THE ARRAY IS USED AS ONE DIMENSIONAL INSIDE AND IS PASSED
C WITH TWO DIMENSIONAL INFORMATION.

C MICHAEL CARPENTER SEPTEMBER 25, 1982

C   ***********************************************************

        DIMENSION KORD(5), NET(5), NNS(3)
        INTEGER NDIMX,KN, KNM1, KNM2, KNM3, LN, LNM1, LNM2, LNM3
C

# include "rgrid.h"

       REAL ARRAY2(NX,NY),ARRAY1(NX*NY)
C
       DO 5 J=1,NY
       DO 5 I=1,NX
       IJK=I+(J-1)*NX
       ARRAY1(IJK)=ARRAY2(I,J)
  5    CONTINUE
C
        IF (NSTEP .LE. 0) RETURN
        N3=1

C   INITIALIZE THE 3-D ARITHMETIC.

      NDIMX=1
      IF(NY.GT.1)NDIMX=2
      KORD(1)=MAX0(1,NX)
      KORD(2)=MAX0(1,NY)
      KORD(3)=MAX0(1,N3)
      KORD(4)=KORD(1)
      KORD(5)=KORD(2)
      NET(1)=1
      NET(2)=KORD(1)
      NET(3)=KORD(1)*KORD(2)
      NET(4)=NET(1)
      NET(5)=NET(2)

C   DEFAULT PARAMETER TRANSFER.

	DO 10 N=1,NDIMX
		NNS(N)=NSTEP
   10	CONTINUE

	MPYRMD=NSTEP+NSTEP-1
	IF(MPYRMD.LE.0)RETURN
	MSTEP=(MPYRMD+1)/2

C   ***** START THE MAIN LOOP *****

      K1=1
      DO 50 MAIN=1,MPYRMD

      DO 40 N=1,NDIMX

C   SAMPLING CHECKS.

      IF(10*K1.GT.KORD(N))NNS(N)=MIN0(NNS(N),MAIN)
      IF((MAIN.GE.NNS(N)).AND.(MPYRMD-MAIN.GE.NNS(N)))GO TO 40

C   THE 3-D ARITHMETIC.

        NP1 = N + 1
        NP2 = N + 2
        M1 = K1 * NET(N)
        M2 = M1 + M1
        M3 = M2 + M1
        ISTOP = KORD(N + 1)
        JSTOP = KORD(N + 2)

        DO 30 I = 1, ISTOP
                DO 30 J = 1, JSTOP
                        KSTRT = 1 + (I-1) * NET(NP1) + (J-1) * NET(NP2)
                        KSTOP = KSTRT + (KORD(N) - 1) * NET(N)
                        KN = KSTRT - NET(N)
                        DO 30 K = 1, K1
                                KN = KN + NET(N)
                                LN = KN + ((KSTOP - KN) / M1) * M1
                                KNM1 = KN + M1
                                KNM2 = KN + M2
                                KNM3 = KN + M3
                                LNM1 = LN - M1
                                LNM2 = LN - M2
                                LNM3 = LN - M3

C   FILTER THE ENDS USING A MIRROR EXTENSION.

                                YKN = .875 * ARRAY1(KN) + .1875 *
     1                              ARRAY1(KNM1) - .0625*ARRAY1(KNM2)

                                YLN = .875 * ARRAY1(LN) + .1875 *
     1                              ARRAY1(LNM1) - .0625*ARRAY1(LNM2)

                                YKN1 = .5625 * ARRAY1(KNM1)
     1                                 +.25*(ARRAY1(KN)+ARRAY1(KNM2))
     2                                  - .0625 * ARRAY1(KNM3)

                                YLN1 = .5625 * ARRAY1(LNM1)
     1                                  +.25*(ARRAY1(LN)+ARRAY1(LNM2))
     2                                  - .0625 * ARRAY1(LNM3)

C   DO THE CENTRAL 5-PT FILTER.

                                YM2=ARRAY1(KN)
                                YM1=ARRAY1(KNM1)
                                MSTRT=KNM2
                                MSTOP=LNM2

                                DO 20 M=MSTRT,MSTOP,M1
                                        MM1 = M + M1
                                        MM2 = M + M2
                                        YSAVE=ARRAY1(M)
                                        ARRAY1(M) = .625 * ARRAY1(M)
     1                                      + .25*(YM1+ARRAY1(MM1))
     2                                      - .0625*(YM2+ARRAY1(MM2))
                                        YM2=YM1
                                        YM1=YSAVE
   20                           CONTINUE

                                ARRAY1(KNM1)=YKN1
                                ARRAY1(LNM1)=YLN1
                                ARRAY1(KN)=YKN
                                ARRAY1(LN)=YLN

   30   CONTINUE
   40   CONTINUE

C   UPDATE THE SAMPLING INCREMENT.

        K1=K1+K1
        IF(MAIN.GE.MSTEP)K1=K1/4
   50   CONTINUE

       DO 60 J=1,NY
       DO 60 I=1,NX
       IJK=I+(J-1)*NX
       ARRAY2(I,J)=ARRAY1(IJK)
  60   CONTINUE
        RETURN
        END




       SUBROUTINE DVRG(A1,A2,DVG)

C       WES WILSON              JUNE,1979

C     THIS ROUTINE COMPUTES THE DIVERGENCE OF THE FIELD (A1,A2) ON
C     THE REGULAR GRID OF SIZE (NX,NY) AND WITH X-INCREMENT DX AND
C     Y-INCREMENT DY.  THE DERIVATIVES ARE APPROXIMATED BY CENTERED
C     DIFFERENCES WHERE POSSIBLE AND BY ONE-SIDED DIFFERENCES NEAR
C     THE BOUNDARY AS NECESSARY.

C

# include "rgrid.h"

       REAL A1(NX,NY),A2(NX,NY),DVG(NX,NY)
C

C     COMPUTE THE DIVERGENCE AROUND THE BOUNDARY.

        DDX = DX + DX
        DDY = DY + DY

        NXM1 = NX - 1
        NYM1 = NY - 1

	DVG(1,1) = DU(A1,2,1,1)/DX+DV(A2,1,2,1)/DY
        DVG(NX,1) = DU(A1,NX,NXM1,1)/DX+DV(A2,NX,2,1)/DY
        DVG(1,NY) = DU(A1,2,1,NY)/DX+DV(A2,1,NY,NYM1)/DY
        DVG(NX,NY) = DU(A1,NX,NXM1,NY)/DX+DV(A2,NX,NY,NYM1)/DY

	DO 100 I=2,NXM1
		DVG(I,1)=DU(A1,I+1,I-1,1)/(DDX)+DV(A2,I,2,1)/DY
		DVG(I,NY)=DU(A1,I+1,I-1,NY)/(DDX)+DV(A2,I,NY,NYM1)/DY
  100	CONTINUE

	DO 200 J=2,NYM1
		DVG(1,J)=DU(A1,2,1,J)/DX+DV(A2,1,J+1,J-1)/(DDY)
		DVG(NX,J)=DU(A1,NX,NXM1,J)/DX+DV(A2,NX,J+1,J-1)/(DDY)
  200	CONTINUE

C     COMPUTE THE DIVERGENCE ON THE INTERIOR.

	DO 300 J = 2, NYM1
		DO 300 I = 2, NXM1
			DVG(I, J) =   DU(A1,  I + 1, I - 1, J) / DDX
     1				    + DV(A2,  I, J + 1, J - 1) / DDY
  300   CONTINUE

	RETURN
	END




       FUNCTION DU(ARRAY,I,J,K)

# include "rgrid.h"

       REAL ARRAY(NX,NY)
C
       DU=ARRAY(I,K)-ARRAY(J,K)
       RETURN
       END




       FUNCTION DV(ARRAY,I,J,K)

# include "rgrid.h"

       REAL ARRAY(NX,NY)
C
       DV=ARRAY(I,J)-ARRAY(I,K)
       RETURN
       END




       SUBROUTINE APPROX(PAM,GRID,SCR1,MODE,XIN,INDEX)
C ROUTINE TO CALCULATE THE APPROXIMATION TO THE RAW PAM DATA USING EITHER
C THE LINEAR INTERPOLATION TECHNIQUE OR A POLYNOMIAL REGRESSION.

# include "rgrid.h"

       REAL PAM(MAXSTN),GRID(NX,NY),SCR1(NX,NY),B(21),XIN(21,MAXSTN)
C
C LINEAR INTERPOLATION
       IF(NAPROX.EQ.0) THEN
         CALL GENWT(PAM)
         CALL INTRP(GRID,SCR1,MODE)
       ENDIF
C POLYNOMIAL CURVE-FIT
       IF(NAPROX.EQ.1) THEN
         CALL POLYFIT(PAM,XIN,INDEX,B)
         CALL EVAL(GRID,B,INDEX,MODE)
       ENDIF
C QUADRATIC INTERPOLATION
       IF(NAPROX.EQ.2) THEN
         CALL QUAD(PAM)
         CALL INTRP(GRID,SCR1,MODE)
       ENDIF
C FIT A CURVE TO PATCHES OF THE GRID.
       IF(NAPROX.EQ.3) CALL PATCH(PAM,GRID,MODE,XIN)
       RETURN
       END




       SUBROUTINE TEST

# include "rgrid.h"

C
  1    WRITE(LUOUT,10)
  10   FORMAT(' CHANGE DATA(0=NO,1=YES)')
       READ(LUIN,*) IX
       IF(IX.NE.0.AND.IX.NE.1) GO TO 1
       IF(IX.EQ.0) RETURN
C
 20    WRITE(LUOUT,30)
 30    FORMAT(' ENTER NO. STATIONS')
       READ(LUIN,*) NP
       DO 100 I=1,NP
       DELETED(I)=.FALSE.
 40    WRITE(LUOUT,50) I
 50    FORMAT(' ENTER X,Y,Z FOR STATION',I6)
       READ(LUIN,*) X(I),Y(I),Z(I)
 100   CONTINUE
       RETURN
       END




       SUBROUTINE QUAD(PAM)
C ROUTINE TO COMPUTE THE INTERPOLATION WEIGHTS FOR ALL TRIANGLES
C USING A QUADRATIC INTERPOLATION POLYNOMIAL.

# include "rgrid.h"

       REAL PAM(MAXSTN)
C
C LOOP THROUGH THE TRIANGLES.
       DO 10 I=1,ITRS
       CALL QUADWT(I,PAM)
  10   CONTINUE
       RETURN
       END




       SUBROUTINE QUADWT(NTR,PAM)
C ROUTINE TO CALCULATE THE INTERPOLATION WEIGHTS FOR TRIANGLE NTR
C USING A QUADRATIC INTERPOLATION POLYNOMIAL.  PAM() IS THE FIELD
C DATA AT THE PAM STATIONS

# include "rgrid.h"

       INTEGER ISTA(6),IADJTR(3)
       REAL XIN(21,MAXSTN),PAM(MAXSTN),B(21),W(MAXSTN)
C
C FIND THE PAM STATIONS COMPRISING TRIANGLE NTR AND THE THREE
C TRIANGLES ADJACENT TO NTR.
C INDEX IS ELEMENT OF XIN() IN WHICH THE INDEPENDENT VARIABLE IS STORED.
       INDEX=6
       DO 10 I=1,3
C STATIONS IN NTR.
       ISTA(I)=ITRNGL(NTR,I)
C ADJACENT TRIANGLES.
       IADJTR(I)=ITRNGL(NTR,I+3)
C SET FLAG IF NOT THREE ADJACENT TRIANGLES.
       IF(IADJTR(I).LE.0) INDEX=3
  10   CONTINUE
C USE LINEAR INTERPOLATION IF DON'T HAVE 3 ADJACENT TRIANGLES.
       IF(INDEX.EQ.3) GO TO 100
C
C FIND THE STATIONS OF THE ADJACENT TRIANGLES THAT ARE NOT IN NTR.
       ISTNS=3
       DO 50 I=1,3
       DO 20 J=1,3
C JTH STATION OF ITH ADJACENT TRIANGLE.
       JSTA=ITRNGL(IADJTR(I),J)
C SEE IF ALREADY HAVE IT.
       DO 30 K=1,ISTNS
       IF(ISTA(K).EQ.JSTA) GO TO 20
  30   CONTINUE
C JSTA IS A NEW STATION.
       ISTNS=ISTNS+1
       ISTA(ISTNS)=JSTA
  20   CONTINUE
  50   CONTINUE
C USE A LINEAR INTERPOLATION IF DON'T HAVE 6 DIFFERENT PAM STATIONS.
       IF(ISTNS.LT.6) INDEX=3
C
C IF NOT THREE ADJACENT TRIANGLES, INTERPOLATE USING A LINEAR INTERPOLATION.
 100   IF(INDEX.NE.6) THEN
         X1=9.*(X(ISTA(1))-XMIN)/(XMAX-XMIN)+1.
         X2=9.*(X(ISTA(2))-XMIN)/(XMAX-XMIN)+1.
         X3=9.*(X(ISTA(3))-XMIN)/(XMAX-XMIN)+1.
         Y1=9.*(Y(ISTA(1))-YMIN)/(YMAX-YMIN)+1.
         Y2=9.*(Y(ISTA(2))-YMIN)/(YMAX-YMIN)+1.
         Y3=9.*(Y(ISTA(3))-YMIN)/(YMAX-YMIN)+1.
         WEIGHT(NTR,3)=PAM(ISTA(1))*(X3-X2)+PAM(ISTA(2))*(X1-X3)
     *+PAM(ISTA(3))*(X2-X1)
         WEIGHT(NTR,3)=WEIGHT(NTR,3)/(Y1*(X3-X2)+Y2*(X1-X3)+
     *Y3*(X2-X1))
         WEIGHT(NTR,2)=PAM(ISTA(2))-PAM(ISTA(1))+WEIGHT(NTR,3)*(Y1-Y2)
         WEIGHT(NTR,2)=WEIGHT(NTR,2)/(X2-X1)
         WEIGHT(NTR,1)=PAM(ISTA(1))-WEIGHT(NTR,3)*Y1
         WEIGHT(NTR,1)=WEIGHT(NTR,1)-X1*(PAM(ISTA(2))-PAM(ISTA(1))+
     *WEIGHT(NTR,3)*(Y1-Y2))/(X2-X1)
         WEIGHT(NTR,4)=0.
         WEIGHT(NTR,5)=0.
         WEIGHT(NTR,6)=0.
         RETURN
       ENDIF
C
C WEIGHT THE STATIONS OF THE INNER TRIANGLE MORE THAN THE STATIONS
C OF THE ADJACENT TRIANGLES.
       DO 190 I=1,3
       W(I)=1.
  190  W(I+3)=.5
C COMPUTE THE MATRIX INPUT TO THE CURVE-FIT SUBROUTINE.
       DO 200 I=1,ISTNS
       XX=9.*(X(ISTA(I))-XMIN)/(XMAX-XMIN)+1.
       YY=9.*(Y(ISTA(I))-YMIN)/(YMAX-YMIN)+1.
       XIN(1,I)=XX
       XIN(2,I)=YY
       XIN(3,I)=XX*YY
       XIN(4,I)=XX*XX
       XIN(5,I)=YY*YY
       XIN(INDEX,I)=PAM(ISTA(I))
 200   CONTINUE
C FIT THE CURVE
       VAL=.01
       IF(NSTEP.EQ.2) VAL=.5
       CALL CURFIT(INDEX,INDEX,XIN,W,VAL,VAL,B)
C SAVE THE COEFFICIENTS OF THE EQUATION.
       WEIGHT(NTR,1)=B(INDEX)
       DO 210 I=1,INDEX-1
       WEIGHT(NTR,I+1)=B(I)
  210  CONTINUE
       RETURN
       END




       SUBROUTINE PATCH(PAM,GRID,MODE,XIN)
C FIT A CURVE TO EACH PATCH OF NSIZE BY NSIZE GRID POINTS AND USE
C IT TO INTERPOLATE THE FIELD VALUES AT THE GRID POINTS.

# include "rgrid.h"

       INTEGER IGRPT(150,2)
       REAL PAM(MAXSTN),GRID(NX,NY),XIN(21,MAXSTN)
C
       WRITE(LUOUT,3)
  3    FORMAT(' ENTER NSIZE')
       READ(LUIN,*) NSIZE
       DO 100 J=1,NY,NSIZE
       DO 90 I=1,NX,NSIZE
       NPTS=0
       DO 80 K=0,NSIZE-1
       DO 80 L=0,NSIZE-1
       IF((K+I).LE.NX.AND.(L+J).LE.NY) THEN
         IF(JW(K+I,L+J).GT.0) THEN
           NPTS=NPTS+1
           IGRPT(NPTS,1)=K+I
           IGRPT(NPTS,2)=L+J
         ELSE
           IF(MODE.NE.0) GRID(K+I,L+J)=FLAG
         ENDIF
       ENDIF
  80   CONTINUE
       IF(NPTS.GT.0) CALL FIT(NPTS,IGRPT,PAM,GRID,XIN)
  90   CONTINUE
 100   CONTINUE
       RETURN
       END




       SUBROUTINE FIT(NPTS,IGRPT,PAM,GRID,XIN)

# include "rgrid.h"

       INTEGER IGRPT(150,2),ITLIST(MAXSTN)
       REAL B(21)
       REAL W(MAXSTN),PAM(MAXSTN),GRID(NX,NY),XIN(21,MAXSTN)
C
C GET THE MESONET STATIONS THAT CONTAIN THE NPTS GRID POINTS IN IGRPT().
       NTRS=0
       DO 100 I=1,NPTS
       I1=IGRPT(I,1)
       J1=IGRPT(I,2)
C GET THE THREE MESONET STATIONS THAT FORM TRIANGLE NTR.
       DO 90 J=1,3
       NTR=JW(I1,J1)
C SEE IF STATIONS THAT FORM TRIANGLE NTR ARE ALREADY IN LIST.
       IF(NTRS.GT.0) THEN
         DO 80 K=1,NTRS
         IF(ITRNGL(NTR,J).EQ.ITLIST(K)) GO TO 90
  80     CONTINUE
       ENDIF
C NOT ALREADY IN LIST. ADD IT.
       NTRS=NTRS+1
       ITLIST(NTRS)=ITRNGL(NTR,J)
  90   CONTINUE
  100  CONTINUE
C
       WRITE(LUOUT,123) NTRS,NPTS
  123  FORMAT(' NTRS,NPTS',2I6)
       IF(NTRS.LT.6) THEN
C USE A LINEAR INTERPOLATION FOR ALL GRID POINTS.
         IOLDTR=0
         DO 400 I=1,NPTS
         I1=IGRPT(I,1)
         J1=IGRPT(I,2)
         NTR=JW(I1,J1)
         IF(IOLDTR.NE.NTR) CALL LINWT(NTR,PAM,W1,W2,W3)
         IOLDTR=NTR
         XX=X0+DX*(I1-1)
         YY=Y0+DY*(J1-1)
         GRID(I1,J1)=W1+XX*W2+YY*W3
  400    CONTINUE
         RETURN
       ENDIF
       INDEX=6
       IF(NTRS.GE.10) INDEX=10
       IF(NTRS.GE.15) INDEX=15
C COMPUTE MATRIX INPUT TO CURVE-FIT ROUTINE.
       DO 200 I=1,NTRS
       IPT=ITLIST(I)
       XX=9.*(X(IPT)-XMIN)/(XMAX-XMIN)+1.
       YY=9.*(Y(IPT)-YMIN)/(YMAX-YMIN)+1.
       XIN(1,I)=XX
       XIN(2,I)=YY
       IF(INDEX.GT.3) THEN
         XIN(3,I)=XX*YY
         XIN(4,I)=XX*XX
         XIN(5,I)=YY*YY
         IF(INDEX.GT.6) THEN
           XIN(6,I)=XIN(4,I)*YY
           XIN(7,I)=XIN(5,I)*XX
           XIN(8,I)=XIN(4,I)*XX
           XIN(9,I)=XIN(5,I)*YY
           IF(INDEX.GT.10) THEN
             XIN(10,I)=XIN(9,I)*XX
             XIN(11,I)=XIN(4,I)*XIN(5,I)
             XIN(12,I)=XIN(8,I)*YY
             XIN(13,I)=XIN(4,I)*XIN(4,I)
             XIN(14,I)=XIN(5,I)*XIN(5,I)
           ENDIF
         ENDIF
       ENDIF
       XIN(INDEX,I)=PAM(IPT)
  200  CONTINUE
C
C FIT THE CURVE.
       W(1)=0.
       CALL CURFIT(INDEX,NTRS,XIN,W,.01,.01,B)
C
C EVALUATE THE CURVE AT THE GRID POINTS.
       DO 300 I=1,NPTS
       I1=IGRPT(I,1)
       J1=IGRPT(I,2)
       XX=X0+DX*(I1-1)
       YY=Y0+DY*(J1-1)
       CALL CFITVAL(XX,YY,B,INDEX,GRID(I1,J1))
  300  CONTINUE
       RETURN
       END




       SUBROUTINE LINEAR(ISTA,NPTS,IGRPT,PAM,GRID)
C CALCULATE THE LINEAR INTERPOLATION WEIGHTS FOR THE TRIANGLE
C CONTAINING MESONET STATION ISTA(1-3).  USE THE WEIGHTS TO COMPUTE
C INTERPOLATED VALUES AT THE NPTS GRID POINTS IGRPT().

# include "rgrid.h"

       INTEGER ISTA(3),IGRPT(150,2)
       REAL PAM(MAXSTN),GRID(NX,NY),WGHT(3)
C
         X1=9.*(X(ISTA(1))-XMIN)/(XMAX-XMIN)+1.
         X2=9.*(X(ISTA(2))-XMIN)/(XMAX-XMIN)+1.
         X3=9.*(X(ISTA(3))-XMIN)/(XMAX-XMIN)+1.
         Y1=9.*(Y(ISTA(1))-YMIN)/(YMAX-YMIN)+1.
         Y2=9.*(Y(ISTA(2))-YMIN)/(YMAX-YMIN)+1.
         Y3=9.*(Y(ISTA(3))-YMIN)/(YMAX-YMIN)+1.
         WGHT(3)=PAM(ISTA(1))*(X3-X2)+PAM(ISTA(2))*(X1-X3)
     *+PAM(ISTA(3))*(X2-X1)
         WGHT(3)=WGHT(3)/(Y1*(X3-X2)+Y2*(X1-X3)+
     *Y3*(X2-X1))
         WGHT(2)=PAM(ISTA(2))-PAM(ISTA(1))+WGHT(3)*(Y1-Y2)
         WGHT(2)=WGHT(2)/(X2-X1)
         WGHT(1)=PAM(ISTA(1))-WGHT(3)*Y1
         WGHT(1)=WGHT(1)-X1*(PAM(ISTA(2))-PAM(ISTA(1))+
     *WGHT(3)*(Y1-Y2))/(X2-X1)
C
C EVALUATE THE INTERPOLATION AT THE GRID POINTS.
         DO 10 I=1,NPTS
         I1=IGRPT(I,1)
         J1=IGRPT(I,2)
         XX=X0+DX*(I1-1)
         YY=Y0+DY*(J1-1)
         XX=9.*(XX-XMIN)/(XMAX-XMIN)+1.
         YY=9.*(YY-YMIN)/(YMAX-YMIN)+1.
         GRID(I1,J1)=WGHT(1)+XX*WGHT(2)+YY*WGHT(3)
  10     CONTINUE
         RETURN
         END



# ifdef notdef
	SUBROUTINE TRGCMN ()
c
c Send the addresses of our common blocks TRIAGD and TRGCHR to C routine
c RCVCMN (receive common).  The first element of each common block (and
c hence the address of the block) is passed.  RCVCMN will have to deal
c with the fact that FSTRNG will be passed by descriptor on the VAX.
c

# include "rgrid.h"

	CALL RCVCMN (NP, FSTRNG)
	RETURN
	END
# endif




C
C DATA DICTIONARY FOR THE RGRID SOFTWARE.
C
C INPUT VARIABLES:
C NP - NUMBER OF PAM STATIONS IN A PROJECT THAT HAVE NOT BEEN EXCLUDED
C      USING THE 'EXCLUDE' COMMAND.
C IPAR - ROBOT FIELD NUMBER OF FIELD TO BE PLOTTED.
C IPAROV - ROBOT FIELD NUMBER OF FIELD TO BE OVERLAYED.
C          IPAROV < 0 IF PLOT FIELD VALUES MEASURED AT PAM STATION
C          IPAROV > 0 IF PLOT FIELD VALUES AT GRID POINTS
C          IPAROV = 0 IF NO OVERLAY FIELD.
C NUSRNO(I) - USER NUMBER OF STATION I.
C U(I) - U_WIND SPEED(EAST WIND) OF STATION I, IN M/S.
C V(I) - V_WIND SPEED(NORTH WIND) OF STATION I, IN M/S.
C Z(I) - FIELD VALUE OF STATION I.  USED FOR ALL FIELDS EXCEPT U_WIND
C        AND V_WIND.
C RLAT(I) - LATITUDE OF STATION I, IN DECIMAL DEGREES.
C RLON(I) - LONGITUDE OF STATION I, IN DECIMAL DEGREES.
C RUPLIM(J) -  UPPER RANGE LIMIT OF FIELD WHOSE FIELD NUMBER IS J.  SET BY
C              USE OF 'RGRANGE' COMMAND.  DEFAULT IS 99999.
C RLOLIM(J) - LOWER RANGE LIMIT OF FIELD WHOSE FIELD NUMBER IS J.  SET BY
C             USE OF 'RGRANGE' COMMAND.  DEFAULT IS -99999.
C IALT(I) - ALTITUDE OF STATION I, IN METERS.
C NX - NUMBER OF HORIZONTAL GRID POINTS.
C NY - NUMBER OF VERTICAL GRID POINTS.
C NFLTR - FILTER FLAG.  NFLTR = 0 IF DATA IS NOT FILTERED.
C                       NFLTR = 1 IF DATA IS FILTERED.
C         NFLTR IS USED ONLY WHEN THE LINEAR INTERPOLATION APPROXIMATION
C         TECHNIQUE IS USED.
C NTPLOT - TRIANGULATION PLOT FLAG.  NTPLOT = 0 IF NO PLOT IS DISPLAYED.
C                                    NTPLOT = 1 IF TRIANGULATION PLOT IS
C                                               DISPLAYED.
C NSTEP - FILTER STEP SIZE.
C NAPROX - INDICATOR OF APPROXIMATION METHOD.
C          NAPROX = 0 FOR LINEAR INTERPOLATION METHOD.
C          NAPROX = 1 FOR POLYNOMIAL CURVE-FIT METHOD.
C IDATE - DATE OF RGRID ANALYSIS(PACKED DATA: YYMMDD).
C ITIME - TIME OF RGRID ANALYSIS(PACKED DATA: HHMMSS).
C
C OUTPUT VARIABLES AND VARIABLES USED INTERNALLY:
C NSTNS - NUMBER OF STATIONS INCLUDED IN THE RGRID ANALYSIS.
C DELETED(I) - EXCLUDED STATION INDICATOR.
C             DELETED(I) = .FALSE. IF STATION I IS INCLUDED IN RGRID ANALYSIS.
C             DELETED(I) = .TRUE. IF STATION IS EXCLUDED BECAUSE OF "BAD" DATA
C                           OR OUT-OF-RANGE DATA.
C AREA(I) - AREA OF INFLUENCE OF STATION I, IN SQ. KM.
C ITRS - NUMBER OF TRIANGLES IN THE TRIANGULATION.
C IUSED(I) - SORTED LIST OF PAM STATIONS.  IUSED(1) IS STATION NEAREST
C            MIDPOINT OF RECTANGLE.  IUSED(NSTNS) IS STATION FURTHEST
C            FROM MIDPOINT OF RECTANGLE.
C ITRNGL(*) - ARRAY CONTAINING TRIANGULATION INFORMATION.
C             ITRNGL(I,1-3) - THREE STATIONS THAT FORM TRIANGLE I. ORIENTED
C                             COUNTERCLOCKWISE.  ITRNGL(I,1) IS CLOCKWISE FROM
C                             ITRNGL(I,2), ETC.
C             ITRNGL(I,4-6) - TRIANGLES ADJACENT TO TRIANGLE I.
C                             ITRNGL(I,4) IS THE TRIANGLE THAT SHARES THE
C                             EDGE FORMED BY ITRNGL(I,1) AND ITRNGL(I,2).
C                             ITRNGL(I,5) IS THE TRIANGLE THAT SHARES THE
C                             EDGE FORMED BY ITRNGL(I,2) AND ITRNGL(I,3).
C                             ITRNGL(I,6) IS THE TRIANGLE THAT SHARES THE
C                             EDGE FORMED BY ITRNGL(I,1) AND ITRNGL(I,3).
C IBPTS - NUMBER OF STATIONS THAT FORM THE BOUNDARY OF THE AREA COVERED
C         BY PAM STATIONS.
C IBPTNO - INDEX OF VECTOR IBNDRY(*) WHERE A NEW BOUNDARY STATION IS TO
C          BE INSERTED.
C IBNDRY(I) - ITH STATION OF THE BOUNDARY.  ORIENTED COUNTERCLOCKWISE.
C             IBNDRY(I) IS CLOCKWISE FROM IBNDRY(I+1).
C X(I) - X COORDINATE OF STATION I, IN KM.
C Y(I) - Y COORDINATE OF STATION I, IN KM.
C XMAX, XMIN - MAXIMUM AND MINIMUM VALUES OF X(I) OF PAM STATIONS INCLUDED
C              IN THE RGRID ANALYSIS.
C YMAX, YMIN - MAXIMUM AND MINIMUM VALUES OF Y(I) OF PAM STATIONS INCLUDED
C              IN THE RGRID ANALYSIS.
C X0, Y0 - COORDINATES OF LOWER LEFT GRID POINT OF RECTANGULAR GRID, IN KM.
C DX - X DISTANCE BETWEEN GRID POINTS, IN KM.
C DY - Y DISTANCE BETWEEN GRID POINTS, IN KM.
C JW(1-3,I,J) - THREE STATIONS USED FOR INTERPOLATION OF I,JTH GRID POINT,I.E.
C               THE I,JTH GRID POINT LIES IN THE TRIANGLE FORMED BY THE
C               THREE STATIONS.
C WEIGHT(1-3,I,J) - INTERPOLATION WEIGHTS(BARYCENTRIC COORDINATES) OF THE
C                   I,JTH GRID POINT.
C UU(I,J) - INTERPOLATED U_WIND VALUE AT THE I,JTH GRID POINT, IN M/S.
C VV(I,J) - INTERPOLATED V_WIND VALUE AT THE I,JTH GRID POINT, IN M/S.
C ZZ(I,J) - INTERPOLATED FIELD VALUE AT THE I,JTH GRID POINT.  USED FOR ALL
C           FIELD VALUES EXCEPT U_WIND AND V_WIND.
C FSTRNG - STRING CONTAINING FIELD ACRONYM OF FIELD TO BE PLOTTED.
C NAME - STRING CONTAINING LOWER TEN CHARACTERS OF A STATION NAME.
C FLAG - 'BAD' DATA INDICATOR.  SET TO -99999.
