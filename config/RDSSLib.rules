XCOMM
XCOMM $Id: RDSSLib.rules,v 1.2 1993-07-23 19:27:44 case Exp $
XCOMM
XCOMM Rules specific to the RDSS Libraries project, including some which
XCOMM override definitions in Imake.rules
XCOMM

/*
 * This file defines the following rules.  
 *
 * UILoadFileTarget(loadfile,uisrc)
 *  -- loadfile is the .lf file to be created, and uisrc is the
 *     source file which will be 'read' into uic.  The uisrc file is
 *     read into $(UIC), pager$mode is set to false, and a 
 *     'save <loadfile> all' is performed.
 * 
 * UITestLoadFileTarget(loadfile,uisrc)
 *  -- Same as above, but the loadfile is not named as an all target
 *     and not installed.  The loadfile must be specifically mentioned
 *     in the deplibs parameter of TestProgramTarget to be made when
 *     the test program is being made.
 *
 * UICppLoadFileTarget(loadfile,uisrc,depfiles)
 *  -- uisrc is processed with cpp before being compiled with uic to
 *     produce loadfile.  depfiles is the list of files, other than
 *     uisrc, on which uisrc depends (i.e. include files)
 *
 * UICppLoadFileTarget_1(loadfile,uisrc,uisrc1,depfiles)
 *  -- same as above, but make-lf is run though uic to produce the
 *     loadfile.
 *
 * UILoadFileTarget_2(loadfile,uisrc1,istate,uisrc2)
 *  -- loadfile is a .lf file to be created, uisrc1 and uisrc2 are
 *     2 files to be read into uic, and istate is the initial
 *     state to which ui$initial_state will be set.
 *
 * UILoadFileTarget_3(loadfile,uisrc1,uisrc2,uisrc3)
 *  -- loadfile is a .lf file to be created, uisrc1 and uisrc2 are
 *     2 dependent files, and uiscr3 is the file to be run through
 *     uib. 
 * 
 * InstallObjectsIntoLibrary(library,objects)
 *  -- Adds, using $(ARADD), 'objects' to 'library' as an install
 *     target and an install.lib target.  
 *     Typically, ARADD will be 'ar ruv' and library will be $(LIBRDSS)
 *
 * NormalLibraryTarget (library,objects)
 * --- Adds to a local library used for local development.
 *
 * AddObjectsToLibrary(library,objects)
 *  -- Alias for InstallObjectsIntoLibrary()
 * 
 * TestProgramTarget(program,objects,deplibs,locallibs,syslibs)
 *  -- Same as NormalProgramTarget, except program will not be
 *     installed, nor be part of the All target, but a saber
 *     target will be generated.
 *
 * SaberProgramTarget(program,srclist,objlist,locallibs,syslibs)
 *  -- Redefines the Imake.rules definition to use local conventions
 *     for Saber, such as #setopt ansi.
 *
 * InstallShellScriptDest(program,shell,dest)
 *  -- Installs 'program.shell' in dest with the name 'program' and
 *     permissions $(INSTALLPGMFLAGS)
 *
 * InstallShellScript(program,shell)
 *  -- InstallShellScriptDest(program,shell,$(BINDIR))
 *
 * InstallScript
 *  -- Install a shell script (adds suffix .script)
 *
 * InstallScriptAsIs
 *  -- Installs a shell script with no added suffix
 *
 * InstallProgramWithFlags(program,dest,flags)
 *  -- Generates rules to install an executable program using given
 *     install flags.  Changes Imake.rules by adding the
 *     install.<program> target for installing a specific program.
 *
 * InstallNamedNonExec(srcname,dstname,dest)
 *  -- Generate rules to install a data file
 *
 * InstallNonExecFile(file,dest)
 *  -- Generate rules to install a data file
 *
 * InstallNonExec(file,dest)
 *  -- Generate rules to install a data file, but does not try to
 *     create the destination directory (deprecated)
 *
 * InstallNamedProg(srcname,dstname,dest)
 *  -- Install a program with renaming and no stripping.
 *
 * NormalProgramTarget(program,objects,deplibs,locallibs,syslibs)
 *  -- Redefines rule in Imake.rules, adding program to the
 *     all target.  ALSO generates
 *     the install target for the program.  The parameters:
 *	<program>	Name of program to create (the Makefile target)
 *	<objects>	Objects on which the program depends and which
 *			should be linked.
 *	<deplibs>	Local libraries, such as $(LIBRDSS, which should
 *			be listed as dependencies.  Almost always this
 *			parameter is simply $(DEPLIBS).
 *	<locallibs>	Local libraries required for linking, such as XLIBS,
 *			LIBNETCDF, LIBRDSS, etc.
 *	<syslibs>	System libraries, such as -lm, -ltermcap. Usually
 *			the value of $(SYSLIBS) set in Project.tmpl will 
 *                      suffice.
 *
 * NormalFortranProgramTarget(program,objects,deplibs,locallibs,syslibs)
 *  -- Same as above but used for Fortran programs
 *
 * NormalProgramTargetNoInstall(program,objects,deplibs,locallibs,syslibs)
 *  -- Same as above without an automatic install target.  An install
 *     target should be explicitly included in the Imakefile!
 *
 * BuildIncludes(headers,dstsubdir,dstupdir)
 *  -- Redefines the BuildIncludes of Imake.rules.  Uses cp -p rather than
 *     symbolic links.  The -p option, which hopefully works on most
 *     systems, preserves the modification time of the file so the copy
 *     won't force a remake of any file that includes a header file unless the 
 *     header file has actually changed.  dstsubdir is the subdirectory
 *     path within the include dir where the file will be put.  E.g.
 *     for X this is commonly X11, and dstupdir is the path back to
 *     the topdir, i.e. '..'
 *     RDSS Libraries will most likely always use just 
 *     BuildIncludes(headers,.,.)
 *
 * InstallProgramSetUID(program,dest)
 *  -- Uses $(INSTUIDFLAGS) to install a program with setuid privileges
 *
 * DistfilesTarget(distfiles)
 *  -- Echoes each of the files in distfiles, prepended with the
 *     $(CURRENT_DIR) variable (normally the path of the Imakefile's 
 *     directory relative to the top).  The distfiles are
 *     dependencies, so the target fails (or the file is automatically
 *     checked out if its GNU make and an RCS file) if the file
 *     does not exist.  The distfiles parameter should usually be the
 *     $(DISTFILES) variable.
 *
 * DistfilesSubdirs(subdirs)
 *  -- Propagate the distfiles target to the subdirectories in the
 *     subdirs parameter.  A new value of CURRENT_DIR is passed as
 *     CURRENT_DIR=$(CURRENT_DIR)/$$subdir so that a special top-level
 *     path can be given, as in the case of making a tar file of a
 *     whole distribution.
 * 
 * DistCleanTarget (cleanfiles)
 *  -- Removes files not normally cleaned out during a 'make clean'
 *     process; i.e., installed executables, includes, libraries, etc.
 *
 */


/*
 * Target which creates a .lf file from uisrc, installs it and
 * cleans it as well
 */
#define UILoadFileTarget(loadfile,uisrc) 			@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec(loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc							@@\
	$(RM) loadfile						@@\
	echo read uisrc \; \					@@\
	     set 'ui$$pager_mode' false \; \			@@\
	     save loadfile all | $(UIC)				@@\
								@@\
clean::								@@\
	$(RM) loadfile

/*
 * Target which creates a .lf file from uisrc, installs it and
 * cleans it as well.  Unlike target above, 'ui$pager_mode'
 * is not set
 */
#define UISimpleLoadFileTarget(loadfile,uisrc) 			@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec(loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc							@@\
	$(RM) loadfile						@@\
	echo 'read uisrc ; save loadfile all ; exit' | $(UIC)	@@\
								@@\
clean::								@@\
	$(RM) loadfile

/*
 * Same as above but for test programs.  The load file is not
 * installed and not included in the all target.  Note that this
 * means an Imakefile should specifically mention a test programs
 * dependency on a load file.  This can be done with the deplibs
 * parameter of TestProgramTarget().
 * Ex: TestProgramTarget(test,test.o,$(DEPLIBS) test.lf,...)
 */
#define UITestLoadFileTarget(loadfile,uisrc) 			@@\
								@@\
loadfile: uisrc							@@\
	$(RM) loadfile						@@\
	echo read uisrc \; \					@@\
	     set 'ui$$pager_mode' false \; \			@@\
	     save loadfile all | $(UIC)				@@\
								@@\
clean::								@@\
	$(RM) loadfile

/*
 * Target which creates a .lf file from uisrc, like UILoadFileTarget()
 * above, but the src file is first passed through cpp.  The -E 
 * option is used since it seems to be the most portable, and then
 * the line number info is removed (any line starting with '#')
 *
 * The third parameter, depfiles, is the files which the loadfile
 * is dependent on, besides the uisrc.  
 *
 * $(CLAGS) is included in the CC -E cmd to get -I options to cpp
 */
#define UICppLoadFileTarget(loadfile,uisrc,depfiles)		@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec(loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc depfiles					@@\
	$(RM) loadfile						@@\
	$(CPP) $(ALLINCLUDES) $(ALLDEFINES) uisrc \		@@\
		| sed -e '/^#/d' > /tmp/uisrc.TMP; \ 		@@\
	echo read /tmp/uisrc.TMP \; \				@@\
	     set 'ui$$pager_mode' false \; \			@@\
	     save loadfile all | $(UIC) ; \			@@\
	rm -f /tmp/uisrc.TMP					@@\
								@@\
clean::								@@\
	$(RM) loadfile

/*
 * Same as above, but make-lf is run though uic.
 */

#define UICppLoadFileTarget_1(loadfile,uisrc,uisrc1,uisrc2,depfiles)	@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec(loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc depfiles					@@\
	$(RM) loadfile						@@\
	$(CPP) $(ALLINCLUDES) uisrc \				@@\
		|grep -v '^# [0-9]' | cat -s > ./uisrc2		@@\
	$(BINDIR)/uic < ./uisrc1				@@\
	$(RM) uisrc2						@@\
								@@\
clean::								@@\
	$(RM) loadfile


/*
 * For creating .lf files from a .state (uisrc1) file, specifying
 * the initial state, and then reading a second ui file (uisrc2).
 * The state argument can be quoted if need be: ex. 'init-state'
 */
#define UILoadFileTarget_2(loadfile,uisrc1,istate,uisrc2)	@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec(loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc1 uisrc2						@@\
	$(RM) loadfile						@@\
	echo "read uisrc1 ; \
	      set ui\$$initial_state istate ; \
	      read uisrc2 ; \
	      set ui\$$pager_mode false ; \
	      save loadfile all" | $(UIC)			@@\
								@@\
clean::								@@\
	$(RM) loadfile

/*
 * for RDSS Libraries ui
 */

#define UILoadFileTarget_3(loadfile,uisrc1,uisrc2,uisrc3)		@@\
								@@\
AllTarget(loadfile)						@@\
								@@\
InstallNonExec (loadfile,$(LIBDIR))				@@\
								@@\
loadfile: uisrc1 uisrc2 					@@\
	  ./uib < ./uisrc3					@@\
								@@\
clean::								@@\
	$(RM) loadfile




/*
 * Adds a list of object files to a library on an install.lib target and
 * install target.  Object files are always added or updated in the library, 
 * since the library may be newer because of objects added from other
 * directories while the objects in the library from this directory might 
 * still be out of date.  That's just one of the problems with building 
 * libraries from multiple source dirs!
 *
 */
#define InstallObjectsIntoLibrary(library,objects)		@@\
								@@\
install:: objects						@@\
	MakeDir($(LIBDIR))					@@\
	$(ARADD) library objects				@@\
	$(RANLIB) library					@@\
								@@\
install.lib:: objects						@@\
	MakeDir($(LIBDIR))					@@\
	$(ARADD) library objects				@@\
	$(RANLIB) library					@@\
								@@\

/*
 * Adds a list of object files to a local library.  Uses an all 
 * target.
 */

#define NormalLibraryTarget(library,objects)			@@\
								@@\
AllTarget (library)						@@\
								@@\
library: objects						@@\
	$(RM) $@						@@\
	$(AR) $@ objects					@@\
	$(RANLIB) library 					@@\



#define AddObjectsToLibrary InstallObjectsIntoLibrary


/*
 * Same as NormalProgramTarget, but the program will not
 * be installed, nor it will be an 'all' dependency
 */
#ifndef TestProgramTarget
#define	TestProgramTarget(program,objects,deplibs,locallibs,syslibs)	@@\
									@@\
program: objects deplibs						@@\
	RemoveTargetProgram($@)						@@\
	$(CC) -o $@ objects $(LDOPTIONS) locallibs $(LDLIBS) syslibs $(EXTRA_LOAD_FLAGS) @@\
									@@\
SaberProgramTarget(program,program.c,objects,deplibs locallibs,syslibs) @@\
									@@\
clean::									@@\
	$(RM) program
#endif /* TestProgramTarget */


/* This rule overrides the one defined in Imake.rules!!!  The CLIBS
 * variable can be used to specify which C libraries to use, e.g.
 * /locallib/gcc-gnulib
 * --------------------------------------------------------------------
 * SaberProgramTarget - generate rules to make Saber-C read in sources and
 * objects.
 */
#ifndef SaberProgramTarget
#if HasSaberC
#define SaberProgramTarget(program,srclist,objlist,locallibs,syslibs)	@@\
Concat(saber_,program):: srclist					@@\
	XCOMM setopt ansi						@@\
	XCOMM load $(ALLDEFINES) srclist locallibs $(SYS_LIBRARIES) $(EXTRA_LIBRARIES) syslibs $(CLIBS) @@\
	XCOMM link							@@\
									@@\
Concat(osaber_,program):: objlist					@@\
	XCOMM setopt ansi						@@\
	XCOMM load $(ALLDEFINES) objlist locallibs $(SYS_LIBRARIES) $(EXTRA_LIBRARIES) syslibs $(CLIBS) @@\
	XCOMM link

#else
#define SaberProgramTarget(program,srclist,objlist,locallibs,syslibs) /**/
#endif
#endif
/*
 * Now that we've set the SaberProgramTarget, undefine HasSaberC so that
 * so that we don't get the default saber: and osaber: targets from
 * Imake.tmpl.  This is a kludge since the more correct thing to do would
 * be just to modify Imake.tmpl.  That may yet be done.
 */
#undef HasSaberC
#define HasSaberC NO

/*-----------------------------------------------------------------------
 * The next several rules re-define the install rules in Imake.rules
 * to provide targets of the form install.<target file> whose rules
 * install only the particular file.  These rules are in turn invoked in
 * the definitions of larger rules.
 *-----------------------------------------------------------------------*/

/*
 * InstallShellScriptDest -- Install a shell script of the form program.shell
 * into dest and call it 'program', giving it $(INSTPGMFLAGS)
 * permissions
 */
#ifndef InstallShellScriptDest
#define InstallShellScriptDest(program,shell,dest)			@@\
install:: install.program						@@\
									@@\
install:: program.shell							@@\
	$(INSTALL) -c $(INSTPGMFLAGS) program.shell dest/program
#endif

/*
 * InstallShellScript -- performs InstallShellScriptDest using $(BINDIR)
 * as the dest directory (as in ComplexProgramTarget)
 */
#define InstallShellScript(program,shell)				@@\
InstallShellScriptDest(program,shell,$(BINDIR))


/*
 * InstallProgramWithFlags - generate rules to install an executable program
 * using given install flags.  Changes Imake.rules by adding the
 * install.<program name> target for installing a specific program.
 */
#ifndef InstallProgramWithFlags
#define InstallProgramWithFlags(program,dest,flags)                     @@\
install:: install.program                                               @@\
                                                                        @@\
install.program: program                                                @@\
	MakeDir($(DESTDIR)dest)                                         @@\
	$(INSTALL) -c $(INSTPGMFLAGS) flags program $(DESTDIR)dest
#endif /* InstallProgramWithFlags */

/*
 * InstallNamedNonExec - generate rules to install a data file
 */
#ifndef InstallNamedNonExec
#define InstallNamedNonExec(srcname,dstname,dest)                       @@\
install:: install.dstname                                               @@\
                                                                        @@\
install.dstname: srcname                                                @@\
	MakeDir($(DESTDIR)dest)                                         @@\
	$(INSTALL) -c $(INSTLIBFLAGS) srcname $(DESTDIR)dest/dstname
#endif /* InstallNamedNonExec */

/*
 * InstallNonExecFile - generate rules to install a data file
 */
#ifndef InstallNonExecFile
#define InstallNonExecFile(file,dest)                                   @@\
install:: install.file                                                  @@\
                                                                        @@\
install.file: file                                                      @@\
	MakeDir($(DESTDIR)dest)                                         @@\
	$(INSTALL) -c $(INSTLIBFLAGS) file $(DESTDIR)dest
#endif /* InstallNonExecFile */


/*
 * InstallNonExec - generate rules to install a data file, but does not
 * try to create the destination directory (deprecated)
 */
#ifndef InstallNonExec
#define InstallNonExec(file,dest)                                       @@\
install:: install.file                                                  @@\
                                                                        @@\
install.file: file                                                      @@\
	$(INSTALL) -c $(INSTLIBFLAGS) file $(DESTDIR)dest
#endif /* InstallNonExec */


/*
 * InstallScript - install a shell script.
 */
#ifndef InstallScript
#define InstallScript(program,dest)                                     @@\
install:: install.program                                               @@\
                                                                        @@\
install.program: program.script                                         @@\
	MakeDir($(DESTDIR)dest)                                         @@\
	$(INSTALL) -c $(INSTBINFLAGS) program.script $(DESTDIR)dest/program
#endif /* InstallScript */

/*
 * InstallScriptAsIs - install a shell script with the given name
 */
#ifndef InstallScriptAsIs
#define InstallScriptAsIs(path,program,dest)					@@\
install:: install.program						@@\
									@@\
install.program: path/program						@@\
	MakeDir($(BINDIR))						@@\
	$(INSTALL) -c $(INSTBINFLAGS) path/program $(BINDIR)/program	
#endif /* InstallScriptAsIs */

/*
 * InstallNamedProg - install a program with renaming and no stripping.
 */
#ifndef InstallNamedProg
#define InstallNamedProg(srcname,dstname,dest)                          @@\
install:: install.dstname                                               @@\
                                                                        @@\
install.dstname: srcname                                                @@\
	MakeDir($(DESTDIR)dest)                                         @@\
	$(INSTALL) -c $(INSTBINFLAGS) srcname $(DESTDIR)dest/dstname
#endif /* InstallNamedProg */


/* This overrides the definition in Imake.rules! It adds program to all target
 * -------------------------------------------------------------------------
 * NormalProgramTarget - generate rules to compile and link the indicated 
 * program; since it does not use any default object files, it may be used for
 * multiple programs in the same Imakefile.  It ALSO adds an install target
 * for the program.  To omit the install target, use
 * NormalProgramTargetNoInstall() below.
 */
#ifndef NormalProgramTarget
#define	NormalProgramTarget(program,objects,deplibs,locallibs,syslibs)	@@\
AllTarget(program)							@@\
									@@\
program: objects deplibs						@@\
	RemoveTargetProgram($@)						@@\
	$(CC) -o $@ objects $(LDOPTIONS) locallibs $(LDLIBS) syslibs $(EXTRA_LOAD_FLAGS) @@\
									@@\
InstallProgram(program,$(BINDIR))					@@\
									@@\
clean::									@@\
	$(RM) program
#endif /* NormalProgramTarget */

/*
 * NormalFortranProgramTarget - same as NormalProgramTarget but for
 * Fortran programs
 */

#ifndef NormalFortranProgramTarget
#define NormalFortranProgramTarget(program,objects,deplibs,locallibs,syslibs)	@@\
AllTarget(program)							@@\
									@@\
program: objects deplibs						@@\
	RemoveTargetProgram($@)						@@\
	$(FC) $(FCFLAGS) -o $@ objects locallibs $(LDLIBS) syslibs $(EXTRA_LOAD_FLAGS)	@@\
									@@\
InstallProgram(program,$(BINDIR))					@@\
									@@\
clean::									@@\
	$(RM) program
#endif /* NormalFortranProgramTarget */



/* 
 * CccProgramTarget - generate rules to compile and link a C++
 * program; since it does not use any default object files, it may be used for
 * multiple programs in the same Imakefile.  It ALSO adds an install target
 * for the program.  This relies on an implicit rule for .cc.o: defined
 * in Project.tmpl.  Note that this macro does not generate a saber target
 * since I don't know what it should look like.  It should be easy enough to
 * to add though.
 */
#ifndef CccProgramTarget
#define	CccProgramTarget(program,objects,deplibs,locallibs,syslibs)	@@\
AllTarget(program)							@@\
									@@\
program: objects deplibs						@@\
	RemoveTargetProgram($@)						@@\
	$(C++) -o $@ objects $(LDOPTIONS) locallibs $(LDLIBS) syslibs $(EXTRA_LOAD_FLAGS) @@\
									@@\
InstallProgram(program,$(BINDIR))					@@\
									@@\
clean::									@@\
	$(RM) program
#endif /* CccProgramTarget */


/*
 * NormalProgramTargetNoInstall -- Same as NormalProgramTarget above,
 * but an install target is not automatically generated for the target
 * program.  Don't use this target for test programs, as the program is
 * still included in the all:: target.  This target is for use when 
 * a special install rule is needed, such as when installing with flags
 * or perhaps installing to a directory other than BINDIR.  So don't 
 * forget to include an install target for this program in the Imakefile!
 */
#ifndef NormalProgramTargetNoInstall
#define	NormalProgramTargetNoInstall(program,objects,deplibs,locallibs,syslibs)	@@\
AllTarget(program)							@@\
									@@\
program: objects deplibs						@@\
	RemoveTargetProgram($@)						@@\
	$(CC) -o $@ objects $(LDOPTIONS) locallibs $(LDLIBS) syslibs $(EXTRA_LOAD_FLAGS) @@\
									@@\
clean::									@@\
	$(RM) program
#endif /* NormalProgramTargetNoInstall */


/*
 * CccProgramTarget(


/*
 * InstallProgramSetUID -- Install a program into 'dest' using
 * the INSTUIDFLAGS variable.  If the user is not 'root', a warning
 * is issued.
 */
#ifndef InstallProgramSetUID
#define InstallProgramSetUID(program,dest)				@@\
install:: program							@@\
	@if [ x$$LOGNAME != xroot ]; then \				@@\
		echo " *** WARNING: You should install" program "as root," ; \ @@\
		echo "              su root and re-do 'make install'"; \ 	@@\
	fi ; \								@@\
	set -x; $(INSTALL) -c $(INSTUIDFLAGS) program dest
#endif


/*
 * Produce a file called prog.flow containing cflow output
 */
#ifndef CflowTarget
#define CflowTarget(prog,objs,locallibs)				@@\
prog.flow:: objs							@@\
	rm -f prog.flow							@@\
	cflow $(ALLDEFINES) objs locallibs >prog.flow

#endif


#ifndef BuildIncludes
#define BuildIncludes(srclist,dstsubdir,dstupdir)			@@\
includes::								@@\
	MakeDir($(BUILDINCDIR)/dstsubdir)				@@\
	@(set -x; cd $(BUILDINCDIR)/dstsubdir; for i in srclist; do \	@@\
		$(RM) $$i; \						@@\
		$(CP) $(CPOPTION) $(RDSSDIR)/$(CURRENT_DIR)/$$i .; \ @@\
	done)
#endif /* BuildIncludes */


/*
 * Echo distribution file lists
 */
#ifndef DistfilesTarget
#define DistfilesTarget(files)						@@\
distfiles:: files							@@\
	@for f in files ; do \						@@\
		echo $(CURRENT_DIR)/$$f ; \				@@\
	done
#endif


/*
 * Propagate the distfiles target to subdirectories
 * Note that we can't use the more standard NamedTargetSubdirs() macro
 * since that macro echoes info that would interfere with the list of files
 * the target is generating
 */
#ifndef DistfilesSubdirs
#define DistfilesSubdirs(dirs)						@@\
distfiles::								@@\
	@case '${MFLAGS}' in *-[ik]*) set +e;; esac; \			@@\
	for i in dirs ;\						@@\
	do \								@@\
		(cd $$i ; \						@@\
		   $(MAKE) $(MFLAGS) CURRENT_DIR=$(CURRENT_DIR)/$$i distfiles); \ @@\
	done
#endif

/*
 * Remove the files that are installed with the install target.
 * Used only for completely cleaning out a distribution, usually
 * so that the build can be restarted from scratch.
 *
 /
#ifndef DistCleanTarget							@@\
#define DistCleanTarget(cleanfiles)					@@\
distclean::								@@\
	$(RM) cleanfiles						@@\
#endif									@@\


/*
 * InstallLibSubdirs --
 * Propagates the install.lib target to subdirectories.
 * PassCDebugFlags IS passed, likewise is DESTDIR as it is in InstallSubdirs()
 */
#ifndef InstallLibSubdirs
#define InstallLibSubdirs(dirs)						@@\
NamedTargetSubdirs(install.lib,dirs,"installing libraries",\
		   PassCDebugFlags DESTDIR='$(DESTDIR)',install.lib)
#endif /* InstallLibSubdirs */


/*
 * This is just to add the familiar mf target as a Makefile: alias,
 * and to add blanks for certain targets in case 
 * the Imakefile does not include them
 */
#ifndef MakefileAdditions
#define MakefileAdditions()						@@\
mf:: Makefile								@@\
	$(MAKE) $(MFLAGS) depend					@@\
									@@\
distfiles::								@@\
									@@\
depend::								@@\
									@@\
install.lib::								@@\

#endif


/*
 * This is almost a direct copy from Imake.rules, except for passing
 * the MFLAGS variable along with the MAKE command.  This is so that
 * the value of MAKE can be passed by setting MFLAGS at the command-line
 * like so:
 * <make program> MFLAGS='MAKE=<make program>'
 */
/*
 * MakeMakeSubdirs - generate rules to recursively recreate Makefiles as part
 * of the specified step in the build.  If $(TOP) is set to an absolute path, 
 * do not prepend the ../ prefix.  This makes running things outside of the 
 * source tree to be much easier.
 */
#ifndef MakeMakeSubdirs
#define MakeMakeSubdirs(dirs,target)					@@\
target::								@@\
	@case '${MFLAGS}' in *-[ik]*) set +e;; esac; \			@@\
	for i in dirs ;\						@@\
	do \								@@\
		echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \	@@\
		case "$$i" in \						@@\
		./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \	@@\
		./?*/?*/?*) newtop=../../../ sub=subsubsub;; \		@@\
		./?*/?*)    newtop=../../ sub=subsub;; \		@@\
		./?*)       newtop=../ sub=sub;; \			@@\
		*/?*/?*/?*)    newtop=../../../../ sub=subsubsubsub;; \	@@\
		*/?*/?*)    newtop=../../../ sub=subsubsub;; \		@@\
		*/?*)       newtop=../../ sub=subsub;; \		@@\
		*)	    newtop=../ sub=sub;; \			@@\
		esac; \							@@\
		case "$(TOP)" in \					@@\
		/?*) newtop=  upprefix=  ;; \				@@\
		*) upprefix=../ ;; \					@@\
		esac; \							@@\
		$(MAKE) $(MFLAGS) $${sub}dirMakefiles \			@@\
		   UPPREFIX=$$upprefix NEWTOP=$$newtop \		@@\
		   MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\ @@\
	done
#endif /* MakeMakeSubdirs */



